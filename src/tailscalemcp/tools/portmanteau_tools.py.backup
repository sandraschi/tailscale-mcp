"""
Tailscale Portmanteau Tools

Consolidated tools following the portmanteau pattern to avoid tool explosion.
Each tool combines multiple related operations into a single, powerful interface.
"""

import time
from typing import Any

import structlog
from fastmcp import FastMCP

from tailscalemcp.config import TailscaleConfig
from tailscalemcp.device_management import AdvancedDeviceManager
from tailscalemcp.exceptions import TailscaleMCPError
from tailscalemcp.funnel import FunnelManager
from tailscalemcp.grafana_dashboard import TailscaleGrafanaDashboard
from tailscalemcp.magic_dns import MagicDNSManager
from tailscalemcp.monitoring import TailscaleMonitor
from tailscalemcp.operations.analytics import AnalyticsOperations
from tailscalemcp.operations.audit import AuditOperations
from tailscalemcp.operations.keys import KeyOperations
from tailscalemcp.operations.network import NetworkOperations
from tailscalemcp.operations.policies import PolicyOperations
from tailscalemcp.operations.policy_analyzer import PolicyAnalyzer
from tailscalemcp.operations.reporting import ReportingOperations
from tailscalemcp.operations.services import ServiceOperations
from tailscalemcp.operations.tags import TagOperations
from tailscalemcp.taildrop import TaildropManager

logger = structlog.get_logger(__name__)


class TailscalePortmanteauTools:
    """Consolidated Tailscale tools using portmanteau pattern."""

    def __init__(
        self,
        mcp: FastMCP,
        device_manager: AdvancedDeviceManager,
        monitor: TailscaleMonitor,
        grafana_dashboard: TailscaleGrafanaDashboard,
        taildrop_manager: TaildropManager,
        magic_dns_manager: MagicDNSManager,
        funnel_manager: FunnelManager | None = None,
        config: TailscaleConfig | None = None,
    ):
        """Initialize portmanteau tools.

        Args:
            mcp: FastMCP instance
            device_manager: Device manager instance
            monitor: Monitoring instance
            grafana_dashboard: Grafana dashboard instance
            taildrop_manager: Taildrop manager instance
            magic_dns_manager: MagicDNS manager instance
            funnel_manager: Funnel manager instance (optional)
        """
        self.mcp = mcp
        self.device_manager = device_manager
        self.monitor = monitor
        self.grafana_dashboard = grafana_dashboard
        self.taildrop_manager = taildrop_manager
        self.magic_dns_manager = magic_dns_manager
        self.funnel_manager = funnel_manager

        # Initialize operations layer - use device_manager config if not provided
        if config is None:
            config = TailscaleConfig(
                tailscale_api_key=device_manager.api_key or "",
                tailscale_tailnet=device_manager.tailnet or "",
            )
        self.config = config

        # Initialize operations classes for use in portmanteau tools
        self.network_ops = NetworkOperations(config=self.config)
        self.policy_ops = PolicyOperations(config=self.config)
        self.audit_ops = AuditOperations(config=self.config)
        self.tag_ops = TagOperations(config=self.config)
        self.key_ops = KeyOperations(config=self.config)
        self.policy_analyzer = PolicyAnalyzer(config=self.config)
        self.analytics_ops = AnalyticsOperations(config=self.config)
        self.reporting_ops = ReportingOperations(config=self.config)
        self.service_ops = ServiceOperations(config=self.config)

        self._register_tools()

    def _register_tools(self) -> None:
        """Register all portmanteau tools."""

        @self.mcp.tool()
        async def tailscale_device(
            operation: str,
            device_id: str | None = None,
            name: str | None = None,
            tags: list[str] | None = None,
            authorize: bool | None = None,
            reason: str | None = None,
            public_key: str | None = None,
            key_name: str | None = None,
            online_only: bool = False,
            filter_tags: list[str] | None = None,
            search_query: str | None = None,
            search_fields: list[str] | None = None,
            enable_exit_node: bool = False,
            advertise_routes: list[str] | None = None,
            enable_subnet_router: bool = False,
            subnets: list[str] | None = None,
            # User management parameters
            user_email: str | None = None,
            user_role: str | None = None,
            user_permissions: list[str] | None = None,
            auth_key_name: str | None = None,
            auth_key_expiry: str | None = None,
            auth_key_reusable: bool = False,
            auth_key_ephemeral: bool = False,
            auth_key_preauthorized: bool = False,
            auth_key_tags: list[str] | None = None,
        ) -> dict[str, Any]:
            """Comprehensive device and user management operations for Tailscale networks.

            This portmanteau tool provides complete device lifecycle management, user administration,
            and authentication key management for Tailscale tailnets. It consolidates 19 operations
            into a single, powerful interface following the portmanteau pattern to avoid tool explosion.

            PORTMANTEAU PATTERN RATIONALE:
            Instead of creating 19 separate tools (one per operation), this tool consolidates related
            device and user management operations into a single interface. This design:
            - Prevents tool explosion (19 tools → 1 tool) while maintaining full functionality
            - Improves discoverability by grouping related operations together
            - Reduces cognitive load when working with device management tasks
            - Enables atomic batch operations across multiple device/user actions
            - Follows FastMCP 2.12+ best practices for feature-rich MCP servers

            The 'operation' parameter determines which specific action to perform, while other parameters
            are operation-specific. This pattern is used throughout the Tailscale MCP server for all
            major feature areas (network, security, monitoring, etc.).

            Use this tool to manage devices (list, authorize, configure), handle user accounts,
            manage authentication keys, and configure advanced features like exit nodes and subnet routing.
            All operations use the Tailscale API with proper rate limiting and error handling.

            SUPPORTED OPERATIONS:

            Device Management:
            - list: List all devices in the tailnet with optional filtering by status and tags.
              Returns device information including name, IP addresses, status, last seen, and metadata.
              Supports filtering to show only online devices or devices with specific tags.

            - get: Retrieve detailed information for a specific device by device ID.
              Returns complete device metadata including configuration, status, tags, and capabilities.

            - authorize: Authorize or revoke device access to the tailnet.
              Use this to approve pending device requests or remove unauthorized devices.

            - rename: Change the display name of a device in the tailnet.
              Useful for organizing devices with meaningful names.

            - tag: Add, remove, or replace device tags for access control and organization.
              Tags are used in ACL policies to control access. Supports add, remove, and replace operations.

            - ssh: Enable or disable SSH access to a device with public key authentication.
              Configure SSH keys for secure remote access to devices.

            - search: Search devices by name, hostname, tags, or OS using flexible query matching.
              Returns all devices matching the search criteria across specified fields.

            - stats: Get comprehensive device statistics including counts, status distribution,
              and aggregate metrics for the entire tailnet.

            Network Configuration:
            - exit_node: Enable or disable exit node functionality on a device.
              Exit nodes allow other devices to route traffic through this device.

            - subnet_router: Enable or disable subnet routing on a device.
              Allows the device to advertise local network routes to the tailnet.

            User Management:
            - user_list: List all users in the tailnet with their roles and permissions.
              Returns user information including email, role, and access details.

            - user_create: Create a new user account in the tailnet.

            - user_update: Update an existing user's role or permissions.

            - user_delete: Remove a user account from the tailnet.

            - user_details: Get detailed information about a specific user.

            Authentication Key Management:
            - auth_key_list: List all authentication keys in the tailnet.
              Returns key information including creation date, expiry, and usage.

            - auth_key_create: Generate a new authentication key for device provisioning.

            - auth_key_revoke: Revoke an existing authentication key.

            - auth_key_rotate: Rotate expired or compromised authentication keys.
              Automatically generates new keys and revokes old ones.

            Args:
                operation: Operation to perform. MUST be one of:
                    - "list": List devices with optional filtering
                    - "get": Get device details by ID
                    - "authorize": Authorize or revoke device access
                    - "rename": Rename a device
                    - "tag": Manage device tags
                    - "ssh": Enable/disable SSH access
                    - "search": Search devices by query
                    - "stats": Get device statistics
                    - "exit_node": Configure exit node functionality
                    - "subnet_router": Configure subnet routing
                    - "user_list": List all users
                    - "user_create": Create new user account
                    - "user_update": Update user details
                    - "user_delete": Remove user account
                    - "user_details": Get user information
                    - "auth_key_list": List authentication keys
                    - "auth_key_create": Generate new auth key
                    - "auth_key_revoke": Revoke authentication key
                    - "auth_key_rotate": Rotate expired keys

                device_id (str | None): Device identifier. Required for: get, authorize, rename, tag, ssh, exit_node, subnet_router. Example: "device123"
                name (str | None): New device name. Required for: rename operation. Example: "john-laptop"
                tags (list[str] | None): List of tags. Required for: tag operation. Format: tag:name. Example: ["tag:engineering", "tag:laptop"]
                authorize (bool | None): Authorization status. Required for: authorize operation. True=authorize, False=revoke
                reason (str | None): Reason for authorization change. Optional for: authorize operation. Example: "New employee device"
                public_key (str | None): SSH public key content. Required for: ssh operation (when enabling). Example: "ssh-rsa AAAAB3NzaC1yc2E..."
                key_name (str | None): SSH key identifier. Optional for: ssh operation. Example: "john-laptop-key"
                online_only (bool): Filter to online devices only. Used by: list operation. Default: False
                filter_tags (list[str] | None): Filter devices by tags. Used by: list operation. Devices must have ALL tags. Example: ["tag:engineering"]
                search_query (str | None): Search query string. Required for: search operation. Searches names, hostnames, tags, OS. Example: "laptop"
                search_fields (list[str] | None): Fields to search in. Optional for: search operation. Default: ["name", "hostname", "tags"]. Valid: "name", "hostname", "tags", "os"
                enable_exit_node (bool): Enable exit node functionality. Used by: exit_node operation. Default: False
                advertise_routes (list[str] | None): Routes to advertise. Used by: exit_node operation (when enabling). Default: ["0.0.0.0/0"]. Example: ["0.0.0.0/0", "192.168.1.0/24"]
                enable_subnet_router (bool): Enable subnet router. Used by: subnet_router operation. Default: False
                subnets (list[str] | None): Subnet routes to advertise. Required for: subnet_router operation (when enabling). Example: ["192.168.1.0/24", "10.0.0.0/8"]
                user_email (str | None): User email address. Required for: user_create, user_update, user_delete, user_details. Example: "user@example.com"
                user_role (str | None): User role. Optional for: user_create, user_update. Example: "admin" or "user"
                user_permissions (list[str] | None): User permissions list. Optional for: user_create, user_update. Example: ["read", "write"]
                auth_key_name (str | None): Authentication key name. Required for: auth_key_create, auth_key_revoke. Example: "deployment-key-2025"
                auth_key_expiry (str | None): Key expiration time. Optional for: auth_key_create.
                    Format: ISO 8601 datetime ("2025-12-31T23:59:59Z") or relative time ("90d", "2w", "1y").
                    Example: "2025-12-31T23:59:59Z" or "90d" (90 days)
                auth_key_reusable (bool): Allow key reuse. Optional for: auth_key_create. Default: False
                auth_key_ephemeral (bool): Ephemeral key. Optional for: auth_key_create. Default: False
                auth_key_preauthorized (bool): Pre-authorize devices. Optional for: auth_key_create. Default: False
                auth_key_tags (list[str] | None): Tags for key. Optional for: auth_key_create. Example: ["tag:server", "tag:production"]

            Returns:
                Dictionary containing operation results. Structure varies by operation:

                For "list" operation:
                    {
                        "operation": "list",
                        "devices": [list of device dictionaries],
                        "count": int,  # Number of devices returned
                        "filters": {
                            "online_only": bool,
                            "filter_tags": list[str]
                        }
                    }

                For "get" operation:
                    {
                        "operation": "get",
                        "device": {device dictionary with full details},
                        "device_id": str
                    }

                For "authorize" operation:
                    {
                        "operation": "authorize",
                        "result": {updated device dictionary},
                        "device_id": str,
                        "authorized": bool
                    }

                For "rename" operation:
                    {
                        "operation": "rename",
                        "result": {updated device dictionary},
                        "device_id": str,
                        "new_name": str
                    }

                For "tag" operation:
                    {
                        "operation": "tag",
                        "result": {updated device dictionary},
                        "device_id": str,
                        "tags": list[str]
                    }

                For "ssh" operation (enable):
                    {
                        "operation": "ssh_enable",
                        "result": {device dictionary with SSH enabled},
                        "device_id": str
                    }

                For "ssh" operation (disable):
                    {
                        "operation": "ssh_disable",
                        "result": {device dictionary with SSH disabled},
                        "device_id": str
                    }

                For "search" operation:
                    {
                        "operation": "search",
                        "results": [list of matching device dictionaries],
                        "query": str,
                        "count": int
                    }

                For "stats" operation:
                    {
                        "operation": "stats",
                        "statistics": {
                            "total_devices": int,
                            "online_devices": int,
                            "offline_devices": int,
                            "unauthorized_devices": int,
                            # Additional statistics...
                        }
                    }

                For "exit_node" operation (enable):
                    {
                        "operation": "exit_node_enable",
                        "result": {device dictionary with exit node enabled},
                        "device_id": str,
                        "advertise_routes": list[str]
                    }

                For "exit_node" operation (disable):
                    {
                        "operation": "exit_node_disable",
                        "result": {device dictionary with exit node disabled},
                        "device_id": str
                    }

                For "subnet_router" operation (enable):
                    {
                        "operation": "subnet_router_enable",
                        "result": {device dictionary with subnet router enabled},
                        "device_id": str,
                        "subnets": list[str]
                    }

                For "subnet_router" operation (disable):
                    {
                        "operation": "subnet_router_disable",
                        "result": {device dictionary with subnet router disabled},
                        "device_id": str
                    }

                For "user_list" operation:
                    {
                        "operation": "user_list",
                        "users": [list of user dictionaries],
                        "count": int
                    }

                For "user_create" operation:
                    {
                        "operation": "user_create",
                        "result": {created user dictionary},
                        "user_email": str,
                        "user_role": str | None
                    }

                For "user_update" operation:
                    {
                        "operation": "user_update",
                        "result": {updated user dictionary},
                        "user_email": str
                    }

                For "user_delete" operation:
                    {
                        "operation": "user_delete",
                        "result": {deletion confirmation},
                        "user_email": str
                    }

                For "user_details" operation:
                    {
                        "operation": "user_details",
                        "result": {user dictionary with full details},
                        "user_email": str
                    }

                For "auth_key_list" operation:
                    {
                        "operation": "auth_key_list",
                        "keys": [list of key dictionaries],
                        "count": int
                    }

                For "auth_key_create" operation:
                    {
                        "operation": "auth_key_create",
                        "result": {created key dictionary with key value},
                        "auth_key_name": str
                    }

                For "auth_key_revoke" operation:
                    {
                        "operation": "auth_key_revoke",
                        "result": {revocation confirmation},
                        "auth_key_name": str
                    }

                For "auth_key_rotate" operation:
                    {
                        "operation": "auth_key_rotate",
                        "result": {
                            "rotated_count": int,
                            "new_keys": [list of new key dictionaries],
                            "revoked_keys": [list of revoked key names]
                        }
                    }

            Raises:
                TailscaleMCPError: If operation fails, invalid parameters provided, or API call fails.
                    Common causes: missing required parameters, invalid device ID, API authentication failure.

                ValueError: If parameter validation fails (e.g., invalid tag format, invalid CIDR range).

                NotFoundError: If requested device, user, or key not found in the tailnet.

            Usage:
                This tool is the primary interface for managing Tailscale devices, users, and authentication.
                Use it to perform device lifecycle management, configure network features, and administer
                user accounts and keys.

                Common workflows:
                - Device onboarding: Use "list" to see pending devices, then "authorize" to approve them
                - Device organization: Use "tag" to organize devices, then "search" to find devices by tag
                - Network configuration: Use "exit_node" or "subnet_router" to configure advanced routing
                - User management: Use "user_list" to see users, then "user_create" or "user_update" to manage
                - Key rotation: Use "auth_key_list" to see keys, then "auth_key_rotate" for security

                Best practices:
                - Always use "get" to verify device details before making changes
                - Use tags consistently for access control and organization
                - Rotate authentication keys regularly for security
                - Document authorization reasons for audit compliance
                - Test exit node and subnet router configurations in staging first

            Examples:
                List all online devices:
                    result = await tailscale_device(
                        operation="list",
                        online_only=True
                    )
                    # Returns: {
                    #     "operation": "list",
                    #     "devices": [{device1}, {device2}, ...],
                    #     "count": 15,
                    #     "filters": {"online_only": True, "filter_tags": []}
                    # }

                List devices with specific tags:
                    result = await tailscale_device(
                        operation="list",
                        filter_tags=["tag:engineering", "tag:laptop"]
                    )
                    # Returns only devices with both tags

                Get device details:
                    result = await tailscale_device(
                        operation="get",
                        device_id="device123"
                    )
                    # Returns: {
                    #     "operation": "get",
                    #     "device": {
                    #         "id": "device123",
                    #         "name": "john-laptop",
                    #         "status": "online",
                    #         ...
                    #     },
                    #     "device_id": "device123"
                    # }

                Authorize a pending device:
                    result = await tailscale_device(
                        operation="authorize",
                        device_id="device456",
                        authorize=True,
                        reason="New employee onboarding"
                    )
                    # Returns device with authorized=True

                Rename a device:
                    result = await tailscale_device(
                        operation="rename",
                        device_id="device123",
                        name="john-laptop-prod"
                    )
                    # Returns device with updated name

                Add tags to device:
                    result = await tailscale_device(
                        operation="tag",
                        device_id="device123",
                        tags=["tag:engineering", "tag:production"]
                    )
                    # Returns device with updated tags

                Enable SSH access:
                    result = await tailscale_device(
                        operation="ssh",
                        device_id="device123",
                        public_key="ssh-rsa AAAAB3NzaC1yc2E...",
                        key_name="admin-key"
                    )
                    # Returns device with SSH enabled

                Search for devices:
                    result = await tailscale_device(
                        operation="search",
                        search_query="laptop",
                        search_fields=["name", "hostname"]
                    )
                    # Returns: {
                    #     "operation": "search",
                    #     "results": [{matching devices}],
                    #     "query": "laptop",
                    #     "count": 5
                    # }

                Get device statistics:
                    result = await tailscale_device(operation="stats")
                    # Returns aggregate statistics for all devices

                Enable exit node:
                    result = await tailscale_device(
                        operation="exit_node",
                        device_id="device789",
                        enable_exit_node=True,
                        advertise_routes=["0.0.0.0/0"]
                    )
                    # Returns device configured as exit node

                Enable subnet router:
                    result = await tailscale_device(
                        operation="subnet_router",
                        device_id="device789",
                        enable_subnet_router=True,
                        subnets=["192.168.1.0/24", "10.0.0.0/8"]
                    )
                    # Returns device configured as subnet router

                List all users:
                    result = await tailscale_device(operation="user_list")
                    # Returns: {
                    #     "operation": "user_list",
                    #     "users": [{user1}, {user2}, ...],
                    #     "count": 25
                    # }

                Create new user:
                    result = await tailscale_device(
                        operation="user_create",
                        user_email="newuser@example.com",
                        user_role="user",
                        user_permissions=["read", "write"]
                    )
                    # Returns created user dictionary

                List authentication keys:
                    result = await tailscale_device(operation="auth_key_list")
                    # Returns all keys with metadata

                Create authentication key:
                    result = await tailscale_device(
                        operation="auth_key_create",
                        auth_key_name="deployment-key-2025",
                        auth_key_expiry="90d",
                        auth_key_reusable=False,
                        auth_key_tags=["tag:server"]
                    )
                    # Returns: {
                    #     "operation": "auth_key_create",
                    #     "result": {
                    #         "key": "tskey-auth-...",
                    #         "name": "deployment-key-2025",
                    #         ...
                    #     },
                    #     "auth_key_name": "deployment-key-2025"
                    # }

                Error handling:
                    try:
                        result = await tailscale_device(
                            operation="get",
                            device_id="nonexistent"
                        )
                    except TailscaleMCPError as e:
                        print(f"Device not found: {e}")
                    # Handles missing device gracefully

            Notes:
                - Device IDs can be either the stable device ID or the device's IP address
                - Tags must follow Tailscale format: "tag:name" (lowercase, alphanumeric + hyphens)
                - Exit nodes require the device to be online and properly configured
                - Subnet routing requires appropriate network permissions on the device
                - Authentication keys are sensitive - store securely and rotate regularly
                - User management operations require appropriate admin permissions
                - All operations are rate-limited to respect Tailscale API limits
                - Device status may take a few seconds to update after configuration changes
                - SSH key management is separate from device authorization
                - Search is case-insensitive and matches partial strings
                - Statistics are calculated in real-time from current device state
                - Related tools: tailscale_network (for DNS/routing), tailscale_security (for audits)
"""
            try:
                if operation == "list":
                    devices = await self.device_manager.list_devices(
                        online_only=online_only, filter_tags=filter_tags or []
                    )
                    return {
                        "operation": "list",
                        "devices": devices,
                        "count": len(devices),
                        "filters": {
                            "online_only": online_only,
                            "filter_tags": filter_tags or [],
                        },
                    }

                elif operation == "get":
                    if not device_id:
                        raise TailscaleMCPError("device_id is required for get operation")
                    device = await self.device_manager.get_device(device_id)
                    return {
                        "operation": "get",
                        "device": device,
                        "device_id": device_id,
                    }

                elif operation == "authorize":
                    if not device_id:
                        raise TailscaleMCPError("device_id is required for authorize operation")
                    if authorize is None:
                        raise TailscaleMCPError("authorize parameter is required")
                    result = await self.device_manager.update_device_authorization(
                        device_id, authorize, reason
                    )
                    return {
                        "operation": "authorize",
                        "result": result,
                        "device_id": device_id,
                        "authorized": authorize,
                    }

                elif operation == "rename":
                    if not device_id or not name:
                        raise TailscaleMCPError("device_id and name are required for rename operation")
                    result = await self.device_manager.rename_device(device_id, name)
                    return {
                        "operation": "rename",
                        "result": result,
                        "device_id": device_id,
                        "new_name": name,
                    }

                elif operation == "tag":
                    if not device_id or not tags:
                        raise TailscaleMCPError("device_id and tags are required for tag operation")
                    result = await self.device_manager.tag_device(device_id, tags, "add")
                    return {
                        "operation": "tag",
                        "result": result,
                        "device_id": device_id,
                        "tags": tags,
                    }

                elif operation == "ssh":
                    if not device_id:
                        raise TailscaleMCPError("device_id is required for SSH operation")
                    if public_key:
                        result = await self.device_manager.enable_ssh_access(
                            device_id, public_key, key_name
                        )
                        return {
                            "operation": "ssh_enable",
                            "result": result,
                            "device_id": device_id,
                        }
                    else:
                        result = await self.device_manager.disable_ssh_access(device_id)
                        return {
                            "operation": "ssh_disable",
                            "result": result,
                            "device_id": device_id,
                        }

                elif operation == "search":
                    if not search_query:
                        raise TailscaleMCPError("search_query is required for search operation")
                    results = await self.device_manager.search_devices(
                        search_query, search_fields
                    )
                    return {
                        "operation": "search",
                        "results": results,
                        "query": search_query,
                        "count": len(results),
                    }

                elif operation == "stats":
                    stats = await self.device_manager.get_device_statistics()
                    return {
                        "operation": "stats",
                        "statistics": stats,
                    }

                elif operation == "exit_node":
                    if not device_id:
                        raise TailscaleMCPError("device_id is required for exit_node operation")
                    if enable_exit_node:
                        result = await self.device_manager.enable_exit_node(
                            device_id, advertise_routes or ["0.0.0.0/0"]
                        )
                        return {
                            "operation": "exit_node_enable",
                            "result": result,
                            "device_id": device_id,
                            "advertise_routes": advertise_routes,
                        }
                    else:
                        result = await self.device_manager.disable_exit_node(device_id)
                        return {
                            "operation": "exit_node_disable",
                            "result": result,
                            "device_id": device_id,
                        }

                elif operation == "subnet_router":
                    if not device_id:
                        raise TailscaleMCPError("device_id is required for subnet_router operation")
                    if enable_subnet_router:
                        if not subnets:
                            raise TailscaleMCPError("subnets are required for enabling subnet router")
                        result = await self.device_manager.enable_subnet_router(device_id, subnets)
                        return {
                            "operation": "subnet_router_enable",
                            "result": result,
                            "device_id": device_id,
                            "subnets": subnets,
                        }
                    else:
                        result = await self.device_manager.disable_subnet_router(device_id)
                        return {
                            "operation": "subnet_router_disable",
                            "result": result,
                            "device_id": device_id,
                        }

                elif operation == "user_list":
                    users = await self.device_manager.list_users()
                    return {
                        "operation": "user_list",
                        "users": users,
                        "count": len(users),
                    }

                elif operation == "user_create":
                    if not user_email:
                        raise TailscaleMCPError("user_email is required for user_create operation")
                    result = await self.device_manager.create_user(user_email, user_role, user_permissions)
                    return {
                        "operation": "user_create",
                        "result": result,
                        "user_email": user_email,
                        "user_role": user_role,
                    }

                elif operation == "user_update":
                    if not user_email:
                        raise TailscaleMCPError("user_email is required for user_update operation")
                    result = await self.device_manager.update_user(user_email, user_role, user_permissions)
                    return {
                        "operation": "user_update",
                        "result": result,
                        "user_email": user_email,
                    }

                elif operation == "user_delete":
                    if not user_email:
                        raise TailscaleMCPError("user_email is required for user_delete operation")
                    result = await self.device_manager.delete_user(user_email)
                    return {
                        "operation": "user_delete",
                        "result": result,
                        "user_email": user_email,
                    }

                elif operation == "user_details":
                    if not user_email:
                        raise TailscaleMCPError("user_email is required for user_details operation")
                    result = await self.device_manager.get_user_details(user_email)
                    return {
                        "operation": "user_details",
                        "result": result,
                        "user_email": user_email,
                    }

                elif operation == "auth_key_list":
                    keys = await self.device_manager.list_auth_keys()
                    return {
                        "operation": "auth_key_list",
                        "keys": keys,
                        "count": len(keys),
                    }

                elif operation == "auth_key_create":
                    if not auth_key_name:
                        raise TailscaleMCPError("auth_key_name is required for auth_key_create operation")
                    result = await self.device_manager.create_auth_key(
                        auth_key_name, auth_key_expiry, auth_key_reusable,
                        auth_key_ephemeral, auth_key_preauthorized, auth_key_tags
                    )
                    return {
                        "operation": "auth_key_create",
                        "result": result,
                        "auth_key_name": auth_key_name,
                    }

                elif operation == "auth_key_revoke":
                    if not auth_key_name:
                        raise TailscaleMCPError("auth_key_name is required for auth_key_revoke operation")
                    result = await self.device_manager.revoke_auth_key(auth_key_name)
                    return {
                        "operation": "auth_key_revoke",
                        "result": result,
                        "auth_key_name": auth_key_name,
                    }

                elif operation == "auth_key_rotate":
                    result = await self.device_manager.rotate_auth_keys()
                    return {
                        "operation": "auth_key_rotate",
                        "result": result,
                    }

                else:
                    raise TailscaleMCPError(f"Unknown operation: {operation}")

            except Exception as e:
                logger.error("Error in tailscale_device operation", operation=operation, error=str(e))
                raise TailscaleMCPError(f"Failed to perform device operation: {e}") from e

        @self.mcp.tool()
        async def tailscale_network(
            operation: str,
            enabled: bool | None = None,
            override_local_dns: bool = False,
            name: str | None = None,
            record_type: str | None = None,
            value: str | None = None,
            ttl: int = 3600,
            hostname: str | None = None,
            use_cache: bool = True,
            domain: str | None = None,
            policy_name: str | None = None,
            rules: list[dict[str, Any]] | None = None,
            priority: int = 100,
            policy_id: str | None = None,  # noqa: ARG001
            # Services (TailVIPs)
            service_id: str | None = None,
            service_payload: dict[str, Any] | None = None,
        ) -> dict[str, Any]:
            """Comprehensive network, DNS, and Services (TailVIPs) management operations.

            This portmanteau tool provides complete network configuration management for Tailscale tailnets,
            including DNS/MagicDNS configuration, network policies, and Tailscale Services (TailVIPs) lifecycle
            management. It consolidates 13 operations into a single interface for network administration.

            PORTMANTEAU PATTERN RATIONALE:
            Instead of creating 13 separate tools (one per operation), this tool consolidates related
            network, DNS, and service management operations into a single interface. This design:
            - Prevents tool explosion (13 tools → 1 tool) while maintaining full functionality
            - Improves discoverability by grouping related operations together
            - Reduces cognitive load when working with network configuration tasks
            - Enables atomic batch operations across multiple network/DNS/service actions
            - Follows FastMCP 2.12+ best practices for feature-rich MCP servers

            The 'operation' parameter determines which specific action to perform, while other parameters
            are operation-specific. This pattern is used throughout the Tailscale MCP server for all
            major feature areas (device, security, monitoring, etc.).

            Use this tool to configure DNS settings, manage MagicDNS, create network policies, and manage
            Tailscale Services that expose internal services to the tailnet with stable IP addresses and
            DNS names. All operations use the Tailscale API with proper error handling and validation.

            SUPPORTED OPERATIONS:

            DNS & MagicDNS Management:
            - dns_config: Retrieve current DNS configuration for the tailnet.
              Returns DNS settings including MagicDNS status, search domains, and custom DNS servers.

            - magic_dns: Enable or disable MagicDNS for the tailnet.
              MagicDNS provides automatic DNS resolution for devices using their hostnames.

            - dns_record: Add a custom DNS record to the tailnet.
              Create A, AAAA, CNAME, or other DNS record types for custom hostname resolution.

            - resolve: Resolve a hostname to IP address(es) using Tailscale DNS.
              Query DNS for A or AAAA records. Supports caching for performance.

            - search_domain: Add or remove DNS search domains for the tailnet.
              Search domains allow short hostname resolution without full FQDN.

            - stats: Get DNS statistics and performance metrics.
              Returns query counts, cache hit rates, resolution times, and error statistics.

            - cache: Clear the DNS cache to force fresh lookups.
              Useful for troubleshooting DNS issues or after configuration changes.

            Network Policy Management:
            - policy: Create or update network access control policies.
              Define ACL rules for controlling access between devices, users, and tags.

            Tailscale Services (TailVIPs) Management:
            - services_list: List all Tailscale Services in the tailnet.
              Returns all configured services with their IPs, DNS names, and endpoints.

            - services_get: Retrieve detailed information for a specific service.
              Get complete service configuration including endpoints, tags, and status.

            - services_create: Create a new Tailscale Service (TailVIP).
              Expose internal services with stable IP addresses and DNS names.

            - services_update: Update an existing Tailscale Service configuration.
              Modify service endpoints, tags, or other settings.

            - services_delete: Remove a Tailscale Service from the tailnet.
              Permanently delete a service and its associated IP/DNS resources.

            Args:
                operation: Operation to perform. MUST be one of:
                    - "dns_config": Get DNS configuration
                    - "magic_dns": Configure MagicDNS
                    - "dns_record": Add DNS record
                    - "resolve": Resolve hostname
                    - "search_domain": Manage search domains
                    - "policy": Create/update network policy
                    - "stats": Get DNS statistics
                    - "cache": Clear DNS cache
                    - "services_list": List all services
                    - "services_get": Get service details
                    - "services_create": Create new service
                    - "services_update": Update service
                    - "services_delete": Delete service

                enabled (bool | None): Enable/disable flag. Required for: magic_dns operation. True=enable, False=disable
                override_local_dns (bool): Override local DNS settings. Used by: magic_dns operation. Default: False
                name (str | None): DNS record name. Required for: dns_record operation. Example: "api.example.com"
                record_type (str | None): DNS record type. Required for: dns_record. Used by: resolve (default: "A").
                    Valid types: "A" (IPv4), "AAAA" (IPv6), "CNAME" (canonical name), "MX" (mail exchange),
                    "TXT" (text), "SRV" (service). Example: "A" for IPv4 address
                value (str | None): DNS record value. Required for: dns_record operation.
                    Format depends on record_type: IP address for A/AAAA, hostname for CNAME/MX, text for TXT.
                    Example: "192.168.1.100" (A record) or "example.com" (CNAME record)
                ttl (int): Time-to-live in seconds. Used by: dns_record operation. Range: 60-86400. Default: 3600
                hostname (str | None): Hostname to resolve. Required for: resolve operation. Example: "device-name" or "device-name.tailnet-name.ts.net"
                use_cache (bool): Use DNS cache. Used by: resolve operation. Default: True
                domain (str | None): Search domain name. Required for: search_domain operation. Example: "internal.company.com"
                policy_name (str | None): Network policy name. Required for: policy operation. Example: "engineering-access-policy"
                rules (list[dict[str, Any]] | None): Network policy rules. Required for: policy operation. ACL rule dicts. Example: [{"action": "accept", "src": ["tag:engineering"], "dst": ["tag:servers:*"]}]
                priority (int): Policy priority. Used by: policy operation. Range: 1-1000. Default: 100
                policy_id (str | None): Policy identifier. Currently unused but reserved for future use.
                service_id (str | None): Service identifier. Required for: services_get, services_update, services_delete. Example: "svc-abc123"
                service_payload (dict[str, Any] | None): Service configuration dictionary. Required for: services_create, services_update.
                    Required keys: "name" (str), "endpoints" (list[dict] with deviceId, port, protocol).
                    Optional keys: "tailvipIPv4", "tailvipIPv6", "magicDNS" (str), "tags" (list[str]).
                    Example: {"name": "api-service", "endpoints": [{"deviceId": "device123", "port": 8080, "protocol": "tcp"}]}

            Returns:
                Dictionary containing operation results. Structure varies by operation:

                For "dns_config" operation:
                    {
                        "operation": "dns_config",
                        "configuration": {
                            "magic_dns_enabled": bool,
                            "search_domains": list[str],
                            "dns_servers": list[str],
                            ...
                        }
                    }

                For "magic_dns" operation:
                    {
                        "operation": "magic_dns",
                        "result": {updated configuration},
                        "enabled": bool,
                        "override_local_dns": bool
                    }

                For "dns_record" operation:
                    {
                        "operation": "dns_record_add",
                        "result": {created record dictionary},
                        "name": str,
                        "record_type": str,
                        "value": str,
                        "ttl": int
                    }

                For "resolve" operation:
                    {
                        "operation": "resolve",
                        "result": {
                            "hostname": str,
                            "record_type": str,
                            "addresses": list[str],
                            "ttl": int
                        },
                        "hostname": str,
                        "record_type": str
                    }

                For "search_domain" operation (add):
                    {
                        "operation": "search_domain_add",
                        "result": {updated configuration},
                        "domain": str
                    }

                For "search_domain" operation (remove):
                    {
                        "operation": "search_domain_remove",
                        "result": {updated configuration},
                        "domain": str
                    }

                For "policy" operation:
                    {
                        "operation": "policy_create",
                        "result": {policy dictionary with ID},
                        "policy_name": str,
                        "rules": list[dict],
                        "priority": int
                    }

                For "stats" operation:
                    {
                        "operation": "stats",
                        "statistics": {
                            "total_queries": int,
                            "cache_hits": int,
                            "cache_misses": int,
                            "average_resolution_time": float,
                            ...
                        }
                    }

                For "cache" operation:
                    {
                        "operation": "cache_clear",
                        "result": {"cleared": True, "entries_cleared": int}
                    }

                For "services_list" operation:
                    {
                        "operation": "services_list",
                        "count": int,
                        "services": [list of service dictionaries]
                    }

                For "services_get" operation:
                    {
                        "operation": "services_get",
                        "service_id": str,
                        "service": {complete service dictionary}
                    }

                For "services_create" operation:
                    {
                        "operation": "services_create",
                        "service": {created service dictionary with service_id}
                    }

                For "services_update" operation:
                    {
                        "operation": "services_update",
                        "service_id": str,
                        "service": {updated service dictionary}
                    }

                For "services_delete" operation:
                    {
                        "operation": "services_delete",
                        "service_id": str,
                        "deleted": True
                    }

            Raises:
                TailscaleMCPError: If operation fails, invalid parameters provided, or API call fails.
                    Common causes: missing required parameters, invalid DNS record format, service not found.

                ValueError: If parameter validation fails (e.g., invalid TTL range, invalid port number).

                NotFoundError: If requested service or DNS record not found.

            Usage:
                This tool is essential for network configuration and service exposure in Tailscale tailnets.
                Use it to configure DNS resolution, manage network access policies, and expose internal
                services with stable IPs and DNS names.

                Common workflows:
                - DNS setup: Use "dns_config" to check current settings, then "magic_dns" to enable
                - Custom DNS: Use "dns_record" to add custom hostname mappings
                - Service exposure: Use "services_create" to expose internal services, then "services_list" to verify
                - Network policies: Use "policy" to create access control rules
                - Troubleshooting: Use "resolve" to test DNS, "cache" to clear cache, "stats" to check performance

                Best practices:
                - Enable MagicDNS for easier device access using hostnames
                - Use search domains for internal network resolution
                - Set appropriate TTL values for DNS records (lower for dynamic, higher for static)
                - Test DNS resolution after configuration changes
                - Use Tailscale Services for stable service exposure instead of device IPs
                - Document network policies with clear names and priorities

            Examples:
                Get DNS configuration:
                    result = await tailscale_network(operation="dns_config")
                    # Returns: {
                    #     "operation": "dns_config",
                    #     "configuration": {
                    #         "magic_dns_enabled": True,
                    #         "search_domains": ["internal.company.com"],
                    #         ...
                    #     }
                    # }

                Enable MagicDNS:
                    result = await tailscale_network(
                        operation="magic_dns",
                        enabled=True,
                        override_local_dns=False
                    )
                    # Returns configuration with MagicDNS enabled

                Add DNS A record:
                    result = await tailscale_network(
                        operation="dns_record",
                        name="api.internal",
                        record_type="A",
                        value="192.168.1.100",
                        ttl=3600
                    )
                    # Returns created DNS record

                Resolve hostname:
                    result = await tailscale_network(
                        operation="resolve",
                        hostname="device-name",
                        record_type="A",
                        use_cache=True
                    )
                    # Returns: {
                    #     "operation": "resolve",
                    #     "result": {
                    #         "hostname": "device-name",
                    #         "addresses": ["100.x.x.x"],
                    #         ...
                    #     },
                    #     "hostname": "device-name",
                    #     "record_type": "A"
                    # }

                Add search domain:
                    result = await tailscale_network(
                        operation="search_domain",
                        domain="internal.company.com",
                        enabled=True
                    )
                    # Returns configuration with search domain added

                Create network policy:
                    result = await tailscale_network(
                        operation="policy",
                        policy_name="engineering-access",
                        rules=[
                            {
                                "action": "accept",
                                "src": ["tag:engineering"],
                                "dst": ["tag:servers:*"]
                            }
                        ],
                        priority=200
                    )
                    # Returns created policy with ID

                Get DNS statistics:
                    result = await tailscale_network(operation="stats")
                    # Returns DNS performance metrics

                Clear DNS cache:
                    result = await tailscale_network(operation="cache")
                    # Returns cache clear confirmation

                List all services:
                    result = await tailscale_network(operation="services_list")
                    # Returns: {
                    #     "operation": "services_list",
                    #     "count": 5,
                    #     "services": [{service1}, {service2}, ...]
                    # }

                Get service details:
                    result = await tailscale_network(
                        operation="services_get",
                        service_id="svc-abc123"
                    )
                    # Returns complete service configuration

                Create Tailscale Service:
                    result = await tailscale_network(
                        operation="services_create",
                        service_payload={
                            "name": "api-service",
                            "tailvipIPv4": "100.101.102.103",
                            "magicDNS": "api.tail",
                            "endpoints": [
                                {"deviceId": "device123", "port": 8080, "protocol": "tcp"}
                            ],
                            "tags": ["prod", "api"]
                        }
                    )
                    # Returns: {
                    #     "operation": "services_create",
                    #     "service": {
                    #         "id": "svc-abc123",
                    #         "name": "api-service",
                    #         ...
                    #     }
                    # }

                Update service:
                    result = await tailscale_network(
                        operation="services_update",
                        service_id="svc-abc123",
                        service_payload={
                            "endpoints": [
                                {"deviceId": "device456", "port": 8080, "protocol": "tcp"}
                            ]
                        }
                    )
                    # Returns updated service configuration

                Delete service:
                    result = await tailscale_network(
                        operation="services_delete",
                        service_id="svc-abc123"
                    )
                    # Returns deletion confirmation

                Error handling:
                    try:
                        result = await tailscale_network(
                            operation="services_get",
                            service_id="nonexistent"
                        )
                    except TailscaleMCPError as e:
                        print(f"Service not found: {e}")
                    # Handles missing service gracefully

            Notes:
                - MagicDNS provides automatic DNS for devices using hostname.tailnet-name.ts.net format
                - DNS records are tailnet-wide and affect all devices
                - Tailscale Services provide stable IPs that persist across device restarts
                - Service endpoints must be on devices that are online and authorized
                - Network policies are evaluated in priority order (higher priority first)
                - DNS cache improves performance but may delay updates after changes
                - Search domains allow short hostname resolution (e.g., "device" instead of "device.tailnet.ts.net")
                - Service IPs are from the 100.x.x.x Tailscale range
                - DNS TTL values affect how quickly changes propagate
                - Related tools: tailscale_device (for device management), tailscale_security (for policy audits)
"""
            try:
                if operation == "dns_config":
                    # Use NetworkOperations for real API calls
                    config = await self.network_ops.get_dns_config()
                    return {
                        "operation": "dns_config",
                        "configuration": config,
                    }

                elif operation == "magic_dns":
                    if enabled is None:
                        raise TailscaleMCPError("enabled parameter is required for magic_dns operation")
                    result = await self.magic_dns_manager.configure_magic_dns(
                        enabled, override_local_dns
                    )
                    return {
                        "operation": "magic_dns",
                        "result": result,
                        "enabled": enabled,
                        "override_local_dns": override_local_dns,
                    }

                elif operation == "dns_record":
                    if not name or not record_type or not value:
                        raise TailscaleMCPError("name, record_type, and value are required for dns_record operation")
                    result = await self.magic_dns_manager.add_dns_record(name, record_type, value, ttl)
                    return {
                        "operation": "dns_record_add",
                        "result": result,
                        "name": name,
                        "record_type": record_type,
                        "value": value,
                        "ttl": ttl,
                    }

                elif operation == "resolve":
                    if not hostname:
                        raise TailscaleMCPError("hostname is required for resolve operation")
                    result = await self.magic_dns_manager.resolve_dns(hostname, record_type or "A", use_cache)
                    return {
                        "operation": "resolve",
                        "result": result,
                        "hostname": hostname,
                        "record_type": record_type or "A",
                    }

                elif operation == "search_domain":
                    if not domain:
                        raise TailscaleMCPError("domain is required for search_domain operation")
                    if enabled:
                        result = await self.magic_dns_manager.add_search_domain(domain)
                        return {
                            "operation": "search_domain_add",
                            "result": result,
                            "domain": domain,
                        }
                    else:
                        result = await self.magic_dns_manager.remove_search_domain(domain)
                        return {
                            "operation": "search_domain_remove",
                            "result": result,
                            "domain": domain,
                        }

                elif operation == "policy":
                    if not policy_name or not rules:
                        raise TailscaleMCPError("policy_name and rules are required for policy operation")
                    # Use NetworkOperations for DNS-related policies, PolicyOperations for ACL policies
                    # For now, use NetworkOperations which has ACL policy methods
                    # Note: This may need to be split into separate operations
                    policy_dict = {
                        "Hosts": {},
                        "Users": {},
                        "Tags": {},
                        "ACLs": rules if isinstance(rules, list) else [],
                        "Groups": {},
                    }
                    result = await self.network_ops.update_acl_policy(policy_dict)
                    return {
                        "operation": "policy_create",
                        "result": result,
                        "policy_name": policy_name,
                        "rules": rules,
                        "priority": priority,
                    }

                elif operation == "stats":
                    stats = await self.magic_dns_manager.get_dns_statistics()
                    return {
                        "operation": "stats",
                        "statistics": stats,
                    }

                elif operation == "cache":
                    result = await self.magic_dns_manager.clear_dns_cache()
                    return {
                        "operation": "cache_clear",
                        "result": result,
                    }

                elif operation == "services_list":
                    services = await self.service_ops.list_services()
                    return {
                        "operation": "services_list",
                        "count": len(services),
                        "services": [s.to_dict() for s in services],
                    }

                elif operation == "services_get":
                    if not service_id:
                        raise TailscaleMCPError("service_id is required for services_get operation")
                    service = await self.service_ops.get_service(service_id)
                    return {
                        "operation": "services_get",
                        "service_id": service_id,
                        "service": service.to_dict(),
                    }

                elif operation == "services_create":
                    if not service_payload:
                        raise TailscaleMCPError("service_payload is required for services_create operation")
                    service = await self.service_ops.create_service(service_payload)
                    return {
                        "operation": "services_create",
                        "service": service.to_dict(),
                    }

                elif operation == "services_update":
                    if not service_id or not service_payload:
                        raise TailscaleMCPError("service_id and service_payload are required for services_update operation")
                    service = await self.service_ops.update_service(service_id, service_payload)
                    return {
                        "operation": "services_update",
                        "service_id": service_id,
                        "service": service.to_dict(),
                    }

                elif operation == "services_delete":
                    if not service_id:
                        raise TailscaleMCPError("service_id is required for services_delete operation")
                    await self.service_ops.delete_service(service_id)
                    return {
                        "operation": "services_delete",
                        "service_id": service_id,
                        "deleted": True,
                    }

                else:
                    raise TailscaleMCPError(f"Unknown operation: {operation}")

            except Exception as e:
                logger.error("Error in tailscale_network operation", operation=operation, error=str(e))
                raise TailscaleMCPError(f"Failed to perform network operation: {e}") from e

        @self.mcp.tool()
        async def tailscale_monitor(
            operation: str,
            grafana_url: str | None = None,
            api_key: str | None = None,
            dashboard_type: str = "comprehensive",
            filename: str | None = None,
            include_panels: bool = True,  # noqa: ARG001
            include_variables: bool = True,  # noqa: ARG001
        ) -> dict[str, Any]:
            """Comprehensive monitoring, metrics, and visualization operations for Tailscale networks.

            This portmanteau tool provides complete monitoring capabilities including real-time metrics collection,
            network topology visualization, health reporting, and Grafana dashboard management. It consolidates
            7 operations for comprehensive network observability.

            PORTMANTEAU PATTERN RATIONALE:
            Instead of creating 7 separate tools (one per operation), this tool consolidates related
            monitoring and visualization operations into a single interface. This design:
            - Prevents tool explosion (7 tools → 1 tool) while maintaining full functionality
            - Improves discoverability by grouping related operations together
            - Reduces cognitive load when working with monitoring tasks
            - Enables atomic batch operations across multiple monitoring/visualization actions
            - Follows FastMCP 2.12+ best practices for feature-rich MCP servers

            The 'operation' parameter determines which specific action to perform, while other parameters
            are operation-specific. This pattern is used throughout the Tailscale MCP server for all
            major feature areas (device, network, security, etc.).

            Use this tool to monitor network performance, generate visualizations, create Grafana dashboards,
            and track network health. All operations integrate with Tailscale's monitoring infrastructure and
            support Prometheus metrics export for integration with monitoring stacks.

            SUPPORTED OPERATIONS:

            Network Monitoring:
            - status: Get real-time network status including device connectivity, latency, and overall health.
              Returns comprehensive status information for the entire tailnet.

            - metrics: Collect comprehensive network metrics including bandwidth, latency, packet loss, and device statistics.
              Returns detailed metrics for performance analysis and troubleshooting.

            - prometheus: Get metrics in Prometheus exposition format for integration with Prometheus monitoring.
              Returns metrics in standard Prometheus text format ready for scraping.

            Network Visualization:
            - topology: Generate network topology map showing device connections and relationships.
              Creates visual representation of the tailnet structure and connectivity.

            - health: Get comprehensive network health report with status, issues, and recommendations.
              Analyzes network state and identifies potential problems or optimization opportunities.

            Grafana Dashboard Management:
            - dashboard: Create and deploy Grafana dashboard to a Grafana instance.
              Automatically creates dashboard with Tailscale metrics and visualizations.

            - export: Export Grafana dashboard configuration to JSON file.
              Saves dashboard configuration for backup, version control, or manual import.

            Args:
                operation: Operation to perform. MUST be one of:
                    - "status": Get network status
                    - "metrics": Collect network metrics
                    - "prometheus": Get Prometheus metrics
                    - "topology": Generate network topology
                    - "health": Get health report
                    - "dashboard": Create Grafana dashboard
                    - "export": Export dashboard to file

                grafana_url (str | None): Grafana instance URL. Required for: dashboard operation. Example: "http://grafana.example.com:3000"
                api_key (str | None): Grafana API key. Required for: dashboard operation. Must have admin permissions. Example: "glsa_abc123..."
                dashboard_type (str): Type of dashboard to create/export. Used by: dashboard, export operations. Default: "comprehensive".
                    Valid: "comprehensive" (full monitoring dashboard), "topology" (network map visualization),
                    "security" (security-focused metrics and alerts)
                filename (str | None): Output filename for export. Required for: export operation. Example: "tailscale-dashboard.json"
                include_panels (bool): Include dashboard panels in export. Used by: export operation. Default: True
                include_variables (bool): Include dashboard variables in export. Used by: export operation. Default: True

            Returns:
                Dictionary containing operation results. Structure varies by operation:

                For "status" operation:
                    {
                        "operation": "status",
                        "status": {
                            "overall": "healthy" | "degraded" | "down",
                            "devices_online": int,
                            "devices_offline": int,
                            "average_latency": float,
                            "connectivity_score": float,
                            ...
                        }
                    }

                For "metrics" operation:
                    {
                        "operation": "metrics",
                        "metrics": {
                            "bandwidth": {"in": float, "out": float},
                            "latency": {"avg": float, "min": float, "max": float},
                            "packet_loss": float,
                            "device_count": int,
                            "timestamp": float,
                            ...
                        }
                    }

                For "prometheus" operation:
                    {
                        "operation": "prometheus",
                        "metrics": "# Prometheus metrics in text format\n..."
                    }

                For "topology" operation:
                    {
                        "operation": "topology",
                        "topology": {
                            "nodes": [list of device nodes],
                            "edges": [list of connections],
                            "layout": "graph structure"
                        }
                    }

                For "health" operation:
                    {
                        "operation": "health",
                        "health_report": {
                            "overall_score": float,
                            "status": "healthy" | "warning" | "critical",
                            "issues": [list of issues],
                            "recommendations": [list of recommendations],
                            ...
                        }
                    }

                For "dashboard" operation:
                    {
                        "operation": "dashboard_create",
                        "dashboard": {Grafana dashboard configuration},
                        "grafana_url": str,
                        "dashboard_id": int
                    }

                For "export" operation:
                    {
                        "operation": "export",
                        "filename": str,
                        "dashboard_type": str,
                        "exported": True
                    }

            Raises:
                TailscaleMCPError: If operation fails, invalid parameters provided, or API call fails.
                    Common causes: missing required parameters, Grafana connection failure, invalid dashboard type.

                ConnectionError: If unable to connect to Grafana instance for dashboard operations.

                ValueError: If parameter validation fails (e.g., invalid URL format, invalid dashboard type).

            Usage:
                This tool is essential for network observability and troubleshooting in Tailscale tailnets.
                Use it to monitor performance, visualize network structure, and create dashboards for
                continuous monitoring.

                Common workflows:
                - Health check: Use "health" to get overall network status and identify issues
                - Performance monitoring: Use "metrics" to collect data, then "prometheus" to export to monitoring stack
                - Visualization: Use "topology" to understand network structure, then "export" to save dashboard
                - Dashboard setup: Use "dashboard" to create Grafana dashboard, then "export" for backup
                - Troubleshooting: Use "status" for quick check, "metrics" for detailed analysis

                Best practices:
                - Regularly check "health" for proactive issue detection
                - Export dashboards for version control and backup
                - Use Prometheus metrics for long-term trend analysis
                - Create separate dashboards for different use cases (comprehensive, topology, security)
                - Monitor metrics over time to establish baselines
                - Use topology visualization to understand network architecture

            Examples:
                Get network status:
                    result = await tailscale_monitor(operation="status")
                    # Returns: {
                    #     "operation": "status",
                    #     "status": {
                    #         "overall": "healthy",
                    #         "devices_online": 25,
                    #         "average_latency": 15.5,
                    #         ...
                    #     }
                    # }

                Collect metrics:
                    result = await tailscale_monitor(operation="metrics")
                    # Returns comprehensive metrics dictionary

                Get Prometheus metrics:
                    result = await tailscale_monitor(operation="prometheus")
                    # Returns: {
                    #     "operation": "prometheus",
                    #     "metrics": "# HELP tailscale_devices_total ...\n..."
                    # }

                Generate topology:
                    result = await tailscale_monitor(operation="topology")
                    # Returns: {
                    #     "operation": "topology",
                    #     "topology": {
                    #         "nodes": [...],
                    #         "edges": [...]
                    #     }
                    # }

                Get health report:
                    result = await tailscale_monitor(operation="health")
                    # Returns: {
                    #     "operation": "health",
                    #     "health_report": {
                    #         "overall_score": 95.5,
                    #         "status": "healthy",
                    #         "issues": [],
                    #         ...
                    #     }
                    # }

                Create Grafana dashboard:
                    result = await tailscale_monitor(
                        operation="dashboard",
                        grafana_url="http://grafana.example.com:3000",
                        api_key="glsa_abc123...",
                        dashboard_type="comprehensive"
                    )
                    # Returns dashboard configuration with ID

                Export dashboard:
                    result = await tailscale_monitor(
                        operation="export",
                        filename="tailscale-dashboard.json",
                        dashboard_type="comprehensive"
                    )
                    # Returns export confirmation

                Error handling:
                    try:
                        result = await tailscale_monitor(
                            operation="dashboard",
                            grafana_url="invalid-url",
                            api_key="key"
                        )
                    except TailscaleMCPError as e:
                        print(f"Dashboard creation failed: {e}")
                    # Handles connection errors gracefully

            Notes:
                - Metrics are collected in real-time and reflect current network state
                - Prometheus metrics follow standard Prometheus exposition format
                - Topology generation may take time for large tailnets
                - Health scores are calculated based on multiple factors (latency, connectivity, etc.)
                - Grafana dashboards require Grafana 7.0+ and admin API access
                - Exported dashboards can be imported manually into Grafana
                - Dashboard types provide different visualizations for different use cases
                - Metrics collection does not persist data - use Prometheus for long-term storage
                - Related tools: tailscale_status (for system status), tailscale_performance (for detailed analysis)
"""
            try:
                if operation == "status":
                    status = await self.monitor.get_network_status()
                    return {
                        "operation": "status",
                        "status": status,
                    }

                elif operation == "metrics":
                    metrics = await self.monitor.collect_metrics()
                    return {
                        "operation": "metrics",
                        "metrics": metrics,
                    }

                elif operation == "prometheus":
                    prometheus_metrics = await self.monitor.get_prometheus_metrics()
                    return {
                        "operation": "prometheus",
                        "metrics": prometheus_metrics,
                    }

                elif operation == "topology":
                    topology = await self.monitor.generate_network_topology()
                    return {
                        "operation": "topology",
                        "topology": topology,
                    }

                elif operation == "health":
                    health_report = await self.monitor.get_network_health_report()
                    return {
                        "operation": "health",
                        "health_report": health_report,
                    }

                elif operation == "dashboard":
                    if not grafana_url or not api_key:
                        raise TailscaleMCPError("grafana_url and api_key are required for dashboard operation")
                    dashboard_config = await self.monitor.create_grafana_dashboard(grafana_url, api_key)
                    return {
                        "operation": "dashboard_create",
                        "dashboard": dashboard_config,
                        "grafana_url": grafana_url,
                    }

                elif operation == "export":
                    if not filename:
                        raise TailscaleMCPError("filename is required for export operation")
                    if dashboard_type == "comprehensive":
                        dashboard_config = self.grafana_dashboard.create_comprehensive_dashboard()
                    elif dashboard_type == "topology":
                        dashboard_config = self.grafana_dashboard.create_network_topology_dashboard()
                    elif dashboard_type == "security":
                        dashboard_config = self.grafana_dashboard.create_security_dashboard()
                    else:
                        raise TailscaleMCPError(f"Unknown dashboard type: {dashboard_type}")

                    self.grafana_dashboard.export_dashboard(dashboard_config, filename)
                    return {
                        "operation": "export",
                        "filename": filename,
                        "dashboard_type": dashboard_type,
                        "exported": True,
                    }

                else:
                    raise TailscaleMCPError(f"Unknown operation: {operation}")

            except Exception as e:
                logger.error("Error in tailscale_monitor operation", operation=operation, error=str(e))
                raise TailscaleMCPError(f"Failed to perform monitor operation: {e}") from e

        @self.mcp.tool()
        async def tailscale_file(
            operation: str,
            file_path: str | None = None,
            recipient_device: str | None = None,
            sender_device: str | None = None,
            expire_hours: int = 24,
            transfer_id: str | None = None,
            save_path: str | None = None,
            status_filter: str | None = None,
        ) -> dict[str, Any]:
            """Comprehensive file sharing operations via Taildrop for secure peer-to-peer file transfer.

            This portmanteau tool provides complete Taildrop functionality for secure file sharing between
            Tailscale devices. Taildrop enables direct device-to-device file transfers without requiring
            external services or cloud storage. It consolidates 7 operations for file transfer management.

            PORTMANTEAU PATTERN RATIONALE:
            Instead of creating 7 separate tools (one per operation), this tool consolidates related
            file sharing operations into a single interface. This design:
            - Prevents tool explosion (7 tools → 1 tool) while maintaining full functionality
            - Improves discoverability by grouping related operations together
            - Reduces cognitive load when working with file transfer tasks
            - Enables atomic batch operations across multiple file transfer actions
            - Follows FastMCP 2.12+ best practices for feature-rich MCP servers

            The 'operation' parameter determines which specific action to perform, while other parameters
            are operation-specific. This pattern is used throughout the Tailscale MCP server for all
            major feature areas (device, network, security, etc.).

            Use this tool to send files between devices, receive incoming transfers, monitor transfer status,
            and manage file sharing operations. All transfers are encrypted end-to-end and use Tailscale's
            secure mesh network for direct device communication.

            SUPPORTED OPERATIONS:

            File Transfer:
            - send: Send a file from one device to another using Taildrop.
              Initiates secure file transfer between devices on the tailnet.

            - receive: Receive a file from an active transfer.
              Downloads and saves a file that was sent via Taildrop.

            Transfer Management:
            - list: List all active file transfers with optional status filtering.
              Shows pending, in-progress, completed, and failed transfers.

            - cancel: Cancel an active file transfer.
              Stops a transfer that is in progress or pending.

            - status: Get detailed status information for a specific transfer.
              Returns current state, progress, and metadata for a transfer.

            Statistics & Maintenance:
            - stats: Get Taildrop statistics including transfer counts and performance metrics.
              Returns aggregate statistics for file sharing operations.

            - cleanup: Clean up expired or failed transfers.
              Removes old transfers that have expired or failed from the system.

            Args:
                operation: Operation to perform. MUST be one of:
                    - "send": Send file to another device
                    - "receive": Receive file from transfer
                    - "list": List active transfers
                    - "cancel": Cancel transfer
                    - "status": Get transfer status
                    - "stats": Get Taildrop statistics
                    - "cleanup": Clean up expired transfers

                file_path (str | None): Path to file to send. Required for: send operation. Example: "/path/to/file.txt"
                recipient_device (str | None): Target device identifier. Required for: send operation. Device ID or hostname. Example: "device123" or "laptop-name"
                sender_device (str | None): Source device identifier. Required for: send operation. Device ID or hostname. Example: "device456" or "server-name"
                expire_hours (int): File expiration time in hours. Used by: send operation. Range: 1-168. Default: 24
                transfer_id (str | None): Transfer identifier. Required for: receive, cancel, status operations. Example: "transfer-abc123"
                save_path (str | None): Destination path for received file. Optional for: receive operation. Defaults to system download directory. Example: "/downloads/received-file.txt"
                status_filter (str | None): Filter transfers by status. Optional for: list operation. Valid: "pending", "in_progress", "completed", "failed", "expired"

            Returns:
                Dictionary containing operation results. Structure varies by operation:

                For "send" operation:
                    {
                        "operation": "send",
                        "result": {
                            "transfer_id": str,
                            "file_path": str,
                            "recipient_device": str,
                            "expire_hours": int,
                            "status": "pending"
                        },
                        "file_path": str,
                        "recipient_device": str,
                        "expire_hours": int
                    }

                For "receive" operation:
                    {
                        "operation": "receive",
                        "result": {
                            "transfer_id": str,
                            "file_path": str,
                            "bytes_received": int,
                            "status": "completed"
                        },
                        "transfer_id": str,
                        "save_path": str
                    }

                For "list" operation:
                    {
                        "operation": "list",
                        "transfers": [list of transfer dictionaries],
                        "count": int,
                        "status_filter": str | None
                    }

                For "cancel" operation:
                    {
                        "operation": "cancel",
                        "result": {"cancelled": True, "transfer_id": str},
                        "transfer_id": str
                    }

                For "status" operation:
                    {
                        "operation": "status",
                        "result": {
                            "transfer_id": str,
                            "status": "pending" | "in_progress" | "completed" | "failed" | "expired",
                            "progress_percent": float,
                            "bytes_transferred": int,
                            "total_bytes": int,
                            "sender": str,
                            "recipient": str,
                            "expires_at": float
                        },
                        "transfer_id": str
                    }

                For "stats" operation:
                    {
                        "operation": "stats",
                        "statistics": {
                            "total_transfers": int,
                            "completed": int,
                            "failed": int,
                            "pending": int,
                            "total_bytes_transferred": int,
                            "average_transfer_time": float,
                            ...
                        }
                    }

                For "cleanup" operation:
                    {
                        "operation": "cleanup",
                        "result": {
                            "cleaned_up": int,
                            "expired_count": int,
                            "failed_count": int
                        }
                    }

            Raises:
                TailscaleMCPError: If operation fails, invalid parameters provided, or API call fails.
                    Common causes: missing required parameters, file not found, device not found, transfer not found.

                FileNotFoundError: If file_path does not exist for send operation.

                PermissionError: If insufficient permissions to read file or write to save_path.

            Usage:
                This tool enables secure file sharing between Tailscale devices without external services.
                Use it to transfer files, monitor transfers, and manage file sharing operations.

                Common workflows:
                - Send file: Use "send" to initiate transfer, then "status" to monitor progress
                - Receive file: Use "list" to see available transfers, then "receive" to download
                - Monitor transfers: Use "list" to see all transfers, "status" for details
                - Maintenance: Use "cleanup" periodically to remove expired transfers
                - Statistics: Use "stats" to monitor file sharing usage and performance

                Best practices:
                - Set appropriate expiration times based on file sensitivity
                - Monitor transfer status for large files
                - Clean up expired transfers regularly
                - Verify recipient device is online before sending
                - Use descriptive file names for easier identification
                - Check transfer status if file doesn't arrive

            Examples:
                Send file to device:
                    result = await tailscale_file(
                        operation="send",
                        file_path="/path/to/document.pdf",
                        recipient_device="laptop-name",
                        sender_device="server-name",
                        expire_hours=48
                    )
                    # Returns: {
                    #     "operation": "send",
                    #     "result": {
                    #         "transfer_id": "transfer-abc123",
                    #         "status": "pending",
                    #         ...
                    #     },
                    #     ...
                    # }

                List active transfers:
                    result = await tailscale_file(operation="list")
                    # Returns: {
                    #     "operation": "list",
                    #     "transfers": [{transfer1}, {transfer2}, ...],
                    #     "count": 3
                    # }

                List pending transfers only:
                    result = await tailscale_file(
                        operation="list",
                        status_filter="pending"
                    )
                    # Returns only pending transfers

                Get transfer status:
                    result = await tailscale_file(
                        operation="status",
                        transfer_id="transfer-abc123"
                    )
                    # Returns: {
                    #     "operation": "status",
                    #     "result": {
                    #         "transfer_id": "transfer-abc123",
                    #         "status": "in_progress",
                    #         "progress_percent": 45.5,
                    #         ...
                    #     },
                    #     "transfer_id": "transfer-abc123"
                    # }

                Receive file:
                    result = await tailscale_file(
                        operation="receive",
                        transfer_id="transfer-abc123",
                        save_path="/downloads/received-file.pdf"
                    )
                    # Returns transfer completion confirmation

                Cancel transfer:
                    result = await tailscale_file(
                        operation="cancel",
                        transfer_id="transfer-abc123"
                    )
                    # Returns cancellation confirmation

                Get statistics:
                    result = await tailscale_file(operation="stats")
                    # Returns aggregate file sharing statistics

                Clean up expired transfers:
                    result = await tailscale_file(operation="cleanup")
                    # Returns cleanup results

                Error handling:
                    try:
                        result = await tailscale_file(
                            operation="send",
                            file_path="/nonexistent/file.txt",
                            recipient_device="device123",
                            sender_device="device456"
                        )
                    except TailscaleMCPError as e:
                        print(f"Transfer failed: {e}")
                    # Handles file not found errors

            Notes:
                - File transfers are encrypted end-to-end using Tailscale's secure mesh
                - Transfers work only between devices on the same tailnet
                - Files expire after the specified expiration time
                - Large files may take time to transfer depending on network conditions
                - Both devices must be online for transfers to complete
                - Transfer IDs are unique and can be used to track specific transfers
                - Progress is reported in real-time for active transfers
                - Failed transfers can be retried by sending again
                - Related tools: tailscale_device (for device management), tailscale_status (for network status)
"""
            try:
                if operation == "send":
                    if not file_path or not recipient_device:
                        raise TailscaleMCPError("file_path and recipient_device are required for send operation")
                    result = await self.taildrop_manager.send_file(
                        file_path, recipient_device, sender_device, expire_hours
                    )
                    return {
                        "operation": "send",
                        "result": result,
                        "file_path": file_path,
                        "recipient_device": recipient_device,
                        "expire_hours": expire_hours,
                    }

                elif operation == "receive":
                    # transfer_id is optional when using CLI (receives all pending files)
                    result = await self.taildrop_manager.receive_file(transfer_id, save_path, accept_all=False)
                    return {
                        "operation": "receive",
                        "result": result,
                        "transfer_id": transfer_id,
                        "save_path": save_path,
                    }

                elif operation == "list":
                    transfers = await self.taildrop_manager.list_transfers(status_filter)
                    return {
                        "operation": "list",
                        "transfers": transfers,
                        "count": len(transfers),
                        "status_filter": status_filter,
                    }

                elif operation == "cancel":
                    if not transfer_id:
                        raise TailscaleMCPError("transfer_id is required for cancel operation")
                    result = await self.taildrop_manager.cancel_transfer(transfer_id)
                    return {
                        "operation": "cancel",
                        "result": result,
                        "transfer_id": transfer_id,
                    }

                elif operation == "status":
                    if not transfer_id:
                        raise TailscaleMCPError("transfer_id is required for status operation")
                    result = await self.taildrop_manager.get_transfer_status(transfer_id)
                    return {
                        "operation": "status",
                        "result": result,
                        "transfer_id": transfer_id,
                    }

                elif operation == "stats":
                    stats = await self.taildrop_manager.get_taildrop_statistics()
                    return {
                        "operation": "stats",
                        "statistics": stats,
                    }

                elif operation == "cleanup":
                    result = await self.taildrop_manager.cleanup_expired_transfers()
                    return {
                        "operation": "cleanup",
                        "result": result,
                    }

                else:
                    raise TailscaleMCPError(f"Unknown operation: {operation}")

            except Exception as e:
                logger.error("Error in tailscale_file operation", operation=operation, error=str(e))
                raise TailscaleMCPError(f"Failed to perform file operation: {e}") from e

        @self.mcp.tool()
        async def tailscale_funnel(
            operation: str,
            port: int | None = None,
            allow_tcp: bool = True,
            allow_tls: bool = True,
        ) -> dict[str, Any]:
            """Comprehensive Funnel operations for exposing local services to the public internet.

            This portmanteau tool provides complete Tailscale Funnel functionality for securely
            exposing local services to the public internet via HTTPS with automatic TLS certificates.
            Funnel enables you to share local development servers, web applications, or APIs
            without complex port forwarding or manual certificate management.

            PORTMANTEAU PATTERN RATIONALE:
            Instead of creating 5 separate tools (one per operation), this tool consolidates related
            Funnel operations into a single interface. This design:
            - Prevents tool explosion (5 tools → 1 tool) while maintaining full functionality
            - Improves discoverability by grouping related operations together
            - Reduces cognitive load when working with Funnel tasks
            - Enables atomic batch operations across multiple Funnel actions
            - Follows FastMCP 2.12+ best practices for feature-rich MCP servers

            The 'operation' parameter determines which specific action to perform, while other parameters
            are operation-specific. This pattern is used throughout the Tailscale MCP server for all
            major feature areas (device, network, file, security, etc.).

            Use this tool to enable Funnel for local services, disable Funnel, check Funnel status,
            list active Funnels, and get certificate information. All operations use the Tailscale CLI
            with proper error handling and status reporting.

            SUPPORTED OPERATIONS:

            Funnel Management:
            - funnel_enable: Enable Funnel for a specific port.
              Exposes a local service on the specified port to the public internet via HTTPS.
              Returns a public URL that can be accessed from anywhere.

            - funnel_disable: Disable Funnel for a port or all ports.
              Stops exposing the service to the public internet.

            - funnel_status: Get current Funnel status.
              Returns information about all active Funnel services.

            - funnel_list: List all active Funnel services.
              Shows all ports currently exposed via Funnel with their public URLs.

            - funnel_certificate_info: Get certificate information for a Funnel service.
              Returns TLS certificate details for a specific Funnel service.

            Prerequisites:
                - Tailscale CLI must be installed and accessible
                - Tailscale version 1.38.3 or later required
                - Funnel must be enabled in your tailnet's access control policy
                - The device must have the 'funnel' node attribute in ACL policy

            Parameters:
                operation: Operation to perform. MUST be one of:
                    - 'funnel_enable': Enable Funnel for a port
                    - 'funnel_disable': Disable Funnel
                    - 'funnel_status': Get Funnel status
                    - 'funnel_list': List active Funnels
                    - 'funnel_certificate_info': Get certificate info

                port: Port number (1-65535). Required for: funnel_enable, funnel_disable, funnel_certificate_info.
                    Example: 8080, 3000, 8000

                allow_tcp: Allow TCP connections. Used by: funnel_enable operation. Default: True

                allow_tls: Allow TLS connections. Used by: funnel_enable operation. Default: True

            Returns:
                Dictionary containing operation results. Structure varies by operation.

            Examples:
                Enable Funnel for port 8080:
                    result = await tailscale_funnel(operation='funnel_enable', port=8080)

                Disable Funnel:
                    result = await tailscale_funnel(operation='funnel_disable', port=8080)

                Get status:
                    result = await tailscale_funnel(operation='funnel_status')

            Errors:
                Common errors and solutions:
                - Tailscale CLI not found: Install Tailscale CLI
                - Funnel not enabled in ACL: Add 'funnel' node attribute to ACL policy
                - Invalid port: Port must be between 1 and 65535

            See Also:
                - tailscale_device: For device management
                - tailscale_network: For DNS and network configuration
            """
            try:
                if not self.funnel_manager:
                    raise TailscaleMCPError(
                        "Funnel manager not initialized. Funnel support requires Tailscale CLI."
                    )

                if operation == "funnel_enable":
                    if port is None:
                        raise TailscaleMCPError("port is required for funnel_enable operation")
                    result = await self.funnel_manager.enable_funnel(
                        port=port, allow_tcp=allow_tcp, allow_tls=allow_tls
                    )
                    return {
                        "operation": "funnel_enable",
                        **result,
                    }

                elif operation == "funnel_disable":
                    result = await self.funnel_manager.disable_funnel(port=port)
                    return {
                        "operation": "funnel_disable",
                        **result,
                    }

                elif operation == "funnel_status":
                    result = await self.funnel_manager.get_funnel_status()
                    return {
                        "operation": "funnel_status",
                        **result,
                    }

                elif operation == "funnel_list":
                    funnels = await self.funnel_manager.list_funnels()
                    return {
                        "operation": "funnel_list",
                        "funnels": funnels,
                        "count": len(funnels),
                    }

                elif operation == "funnel_certificate_info":
                    if port is None:
                        raise TailscaleMCPError(
                            "port is required for funnel_certificate_info operation"
                        )
                    result = await self.funnel_manager.get_certificate_info(port=port)
                    return {
                        "operation": "funnel_certificate_info",
                        **result,
                    }

                else:
                    raise TailscaleMCPError(f"Unknown operation: {operation}")

            except Exception as e:
                logger.error("Error in tailscale_funnel operation", operation=operation, error=str(e))
                raise TailscaleMCPError(f"Failed to perform Funnel operation: {e}") from e

        @self.mcp.tool()
        async def tailscale_security(
            operation: str,
            scan_type: str = "comprehensive",
            compliance_standard: str = "SOC2",
            device_id: str | None = None,
            ip_address: str | None = None,
            quarantine_duration: int = 24,
            alert_severity: str = "medium",
            alert_message: str | None = None,
            policy_name: str | None = None,
            rules: list[dict[str, Any]] | None = None,
            priority: int = 100,
            test_mode: bool = False,
            block_duration: int = 3600,
            threat_type: str | None = None,
        ) -> dict[str, Any]:
            """Comprehensive security scanning, compliance validation, and threat response operations.

            This portmanteau tool provides complete security management for Tailscale tailnets, including
            vulnerability scanning, compliance validation, device auditing, threat detection, and security
            policy management. It consolidates 10 operations for comprehensive security operations.

            PORTMANTEAU PATTERN RATIONALE:
            Instead of creating 10 separate tools (one per operation), this tool consolidates related
            security and compliance operations into a single interface. This design:
            - Prevents tool explosion (10 tools → 1 tool) while maintaining full functionality
            - Improves discoverability by grouping related operations together
            - Reduces cognitive load when working with security tasks
            - Enables atomic batch operations across multiple security/compliance actions
            - Follows FastMCP 2.12+ best practices for feature-rich MCP servers

            The 'operation' parameter determines which specific action to perform, while other parameters
            are operation-specific. This pattern is used throughout the Tailscale MCP server for all
            major feature areas (device, network, monitoring, etc.).

            Use this tool to scan for vulnerabilities, validate compliance with standards, audit device security,
            monitor for threats, respond to security incidents, and manage security policies. All operations
            integrate with Tailscale's security infrastructure and provide actionable security insights.

            SUPPORTED OPERATIONS:

            Security Scanning & Assessment:
            - scan: Perform security vulnerability scan on the tailnet.
              Scans devices, configurations, and network for security vulnerabilities and misconfigurations.

            - audit: Conduct comprehensive security audit of devices.
              Audits device configurations, access controls, and security settings for compliance and best practices.

            - report: Generate comprehensive security report.
              Creates detailed security report with findings, compliance status, and recommendations.

            Compliance Validation:
            - compliance: Validate tailnet compliance with security standards.
              Checks compliance with SOC2, PCI-DSS, HIPAA, ISO27001, or other standards.

            Threat Detection & Response:
            - monitor: Monitor network for suspicious activity and security threats.
              Continuously monitors network traffic and device behavior for anomalies and threats.

            - threat: Detect and respond to specific threat types.
              Identifies and responds to known threat patterns and attack vectors.

            - block: Block malicious IP addresses from accessing the tailnet.
              Immediately blocks specified IP addresses to prevent attacks.

            - quarantine: Quarantine a compromised device to isolate it from the network.
              Isolates a device to prevent further damage while investigation occurs.

            Security Policy Management:
            - policy: Create or update security policies for access control and threat prevention.
              Defines security rules and policies for network access and threat response.

            Alerting:
            - alert: Generate security alerts for incidents and threats.
              Creates alerts for security events with specified severity and messaging.

            Args:
                operation: Operation to perform. MUST be one of:
                    - "scan": Security vulnerability scan
                    - "compliance": Compliance validation
                    - "audit": Device security audit
                    - "report": Generate security report
                    - "monitor": Monitor suspicious activity
                    - "threat": Threat detection and response
                    - "block": Block malicious IP addresses
                    - "quarantine": Quarantine compromised device
                    - "policy": Create/apply security policies
                    - "alert": Security alerting

                scan_type (str): Type of security scan. Used by: scan operation. Default: "comprehensive".
                    Valid: "comprehensive" (full scan of all devices/configs), "quick" (fast scan, basic checks),
                    "deep" (thorough scan with detailed analysis)
                compliance_standard (str): Compliance standard to validate. Used by: compliance operation. Default: "SOC2".
                    Valid: "SOC2" (Service Organization Control 2), "PCI-DSS" (Payment Card Industry),
                    "HIPAA" (Health Insurance), "ISO27001" (Information Security), "NIST" (Cybersecurity Framework), "GDPR" (Data Protection)
                device_id (str | None): Device identifier. Required for: quarantine operation. Optional for: audit (audits all if not specified). Example: "device123"
                ip_address (str | None): IP address to block. Required for: block operation. IPv4 or IPv6. Example: "192.168.1.100"
                quarantine_duration (int): Quarantine duration in hours. Used by: quarantine operation. Range: 1-168. Default: 24
                alert_severity (str): Alert severity level. Used by: alert operation. Valid: "low", "medium", "high", "critical". Default: "medium"
                alert_message (str | None): Alert message text. Required for: alert operation. Example: "Unauthorized access attempt detected"
                policy_name (str | None): Security policy name. Required for: policy operation. Example: "block-suspicious-ips"
                rules (list[dict[str, Any]] | None): Security policy rules. Required for: policy operation. Example: [{"action": "block", "condition": "suspicious_activity", "target": "ip_address"}]
                priority (int): Policy priority. Used by: policy operation. Range: 1-1000. Default: 100
                test_mode (bool): Run in test mode without applying changes. Used by: threat operation. Default: False
                block_duration (int): IP block duration in seconds. Used by: block operation. Range: 60-86400. Default: 3600
                threat_type (str | None): Type of threat to detect. Required for: threat operation.
                    Valid: "malware" (malicious software), "intrusion" (unauthorized access attempts),
                    "data_exfiltration" (data theft), "unauthorized_access" (access violations),
                    "ddos" (distributed denial of service), "phishing" (social engineering attacks).
                    Example: "malware"

            Returns:
                Dictionary containing operation results. Structure varies by operation:

                For "scan" operation:
                    {
                        "operation": "scan",
                        "scan_type": str,
                        "results": {
                            "vulnerabilities": [list of vulnerability dictionaries],
                            "risk_score": float,
                            "scan_duration": float,
                            ...
                        },
                        "vulnerabilities_found": int
                    }

                For "compliance" operation:
                    {
                        "operation": "compliance",
                        "standard": str,
                        "results": {
                            "compliant": bool,
                            "score": float,
                            "violations": [list of violations],
                            "recommendations": [list of recommendations],
                            ...
                        },
                        "compliant": bool
                    }

                For "audit" operation:
                    {
                        "operation": "audit",
                        "device_id": str | None,
                        "results": {
                            "issues": [list of security issues],
                            "issue_count": int,
                            "risk_level": str,
                            "recommendations": [list of recommendations],
                            ...
                        },
                        "issue_count": int
                    }

                For "report" operation:
                    {
                        "operation": "report",
                        "report": {
                            "summary": {summary statistics},
                            "vulnerabilities": [list],
                            "compliance_status": {status},
                            "threats": [list],
                            "recommendations": [list],
                            ...
                        },
                        "generated_at": float
                    }

                For "monitor" operation:
                    {
                        "operation": "monitor",
                        "activity": {
                            "suspicious_events": [list of events],
                            "alerts": [list of alerts],
                            "threat_level": str,
                            ...
                        },
                        "alerts_generated": int
                    }

                For "threat" operation:
                    {
                        "operation": "threat_detect",
                        "threat_type": str,
                        "test_mode": bool,
                        "result": {
                            "threats_detected": [list of threats],
                            "actions_taken": [list of actions],
                            "risk_level": str,
                            ...
                        }
                    }

                For "block" operation:
                    {
                        "operation": "block",
                        "ip_address": str,
                        "block_duration": int,
                        "result": {"blocked": True, "expires_at": float}
                    }

                For "quarantine" operation:
                    {
                        "operation": "quarantine",
                        "device_id": str,
                        "quarantine_duration": int,
                        "result": {"quarantined": True, "expires_at": float}
                    }

                For "policy" operation:
                    {
                        "operation": "policy_create",
                        "policy_name": str,
                        "rules": list[dict],
                        "priority": int,
                        "result": {policy dictionary with ID}
                    }

                For "alert" operation:
                    {
                        "operation": "alert",
                        "severity": str,
                        "message": str,
                        "result": {"alert_id": str, "created_at": float}
                    }

            Raises:
                TailscaleMCPError: If operation fails, invalid parameters provided, or API call fails.
                    Common causes: missing required parameters, device not found, invalid IP address.

                ValueError: If parameter validation fails (e.g., invalid severity level, invalid threat type).

                PermissionError: If insufficient permissions for security operations.

            Usage:
                This tool is critical for maintaining security posture and compliance in Tailscale tailnets.
                Use it to proactively identify vulnerabilities, validate compliance, detect threats, and
                respond to security incidents.

                Common workflows:
                - Security assessment: Use "scan" to find vulnerabilities, then "audit" for detailed analysis
                - Compliance validation: Use "compliance" to check standards, then "report" for documentation
                - Threat response: Use "monitor" to detect threats, then "block" or "quarantine" to respond
                - Policy management: Use "policy" to create security rules, then "audit" to verify effectiveness
                - Incident response: Use "threat" to detect specific threats, then "alert" to notify stakeholders

                Best practices:
                - Run regular security scans (weekly or monthly)
                - Validate compliance before audits or certifications
                - Monitor continuously for suspicious activity
                - Respond quickly to threats with block or quarantine
                - Document security incidents with alerts
                - Review and update security policies regularly
                - Use test_mode for threat detection to preview actions

            Examples:
                Perform security scan:
                    result = await tailscale_security(
                        operation="scan",
                        scan_type="comprehensive"
                    )
                    # Returns: {
                    #     "operation": "scan",
                    #     "vulnerabilities_found": 3,
                    #     "results": {...}
                    # }

                Validate compliance:
                    result = await tailscale_security(
                        operation="compliance",
                        compliance_standard="SOC2"
                    )
                    # Returns compliance validation results

                Audit device security:
                    result = await tailscale_security(
                        operation="audit",
                        device_id="device123"
                    )
                    # Returns device audit results with issues

                Generate security report:
                    result = await tailscale_security(operation="report")
                    # Returns comprehensive security report

                Monitor suspicious activity:
                    result = await tailscale_security(operation="monitor")
                    # Returns detected suspicious activity

                Detect specific threat:
                    result = await tailscale_security(
                        operation="threat",
                        threat_type="malware",
                        test_mode=True
                    )
                    # Returns threat detection results (test mode)

                Block malicious IP:
                    result = await tailscale_security(
                        operation="block",
                        ip_address="192.168.1.100",
                        block_duration=7200
                    )
                    # Returns IP blocking confirmation

                Quarantine device:
                    result = await tailscale_security(
                        operation="quarantine",
                        device_id="device123",
                        quarantine_duration=48
                    )
                    # Returns device quarantine confirmation

                Create security policy:
                    result = await tailscale_security(
                        operation="policy",
                        policy_name="block-suspicious-ips",
                        rules=[{"action": "block", "condition": "suspicious"}],
                        priority=200
                    )
                    # Returns created policy

                Generate security alert:
                    result = await tailscale_security(
                        operation="alert",
                        alert_severity="high",
                        alert_message="Unauthorized access attempt detected"
                    )
                    # Returns alert confirmation

                Error handling:
                    try:
                        result = await tailscale_security(
                            operation="quarantine",
                            device_id="nonexistent"
                        )
                    except TailscaleMCPError as e:
                        print(f"Security operation failed: {e}")
                    # Handles errors gracefully

            Notes:
                - Security scans may take time depending on tailnet size and scan type
                - Compliance validation checks against standard requirements and best practices
                - Quarantined devices are isolated but not deleted
                - Blocked IPs are automatically unblocked after block_duration expires
                - Security policies are evaluated in priority order
                - Test mode allows previewing threat responses without taking action
                - Security reports include historical data and trends
                - Alerts are logged for audit trail and compliance
                - Related tools: tailscale_device (for device management), tailscale_network (for network policies)
"""
            try:
                if operation == "scan":
                    scan_results = await self.device_manager.security_scan(scan_type)
                    return {
                        "operation": "scan",
                        "scan_type": scan_type,
                        "results": scan_results,
                        "vulnerabilities_found": len(scan_results.get("vulnerabilities", [])),
                    }

                elif operation == "compliance":
                    compliance_results = await self.device_manager.check_compliance(compliance_standard)
                    return {
                        "operation": "compliance",
                        "standard": compliance_standard,
                        "results": compliance_results,
                        "compliant": compliance_results.get("compliant", False),
                    }

                elif operation == "audit":
                    # Use AuditOperations for comprehensive device audit
                    # device_id is optional - if not provided, audit all devices
                    filters = {}
                    if device_id:
                        # Note: AuditOperations.audit_devices doesn't support device_id filter directly
                        # We'll audit all devices and filter in post-processing if needed
                        pass
                    audit_results = await self.audit_ops.audit_devices(filters=filters)
                    if device_id:
                        # Filter results to specific device if provided
                        audit_results["issues"] = [
                            issue for issue in audit_results.get("issues", [])
                            if issue.get("device_id") == device_id
                        ]
                    return {
                        "operation": "audit",
                        "device_id": device_id,
                        "results": audit_results,
                        "issue_count": audit_results.get("issue_count", 0),
                    }

                elif operation == "report":
                    security_report = await self.device_manager.generate_security_report()
                    return {
                        "operation": "report",
                        "report": security_report,
                        "generated_at": time.time(),
                    }

                elif operation == "monitor":
                    suspicious_activity = await self.device_manager.monitor_suspicious_activity()
                    return {
                        "operation": "monitor",
                        "activity": suspicious_activity,
                        "alerts_generated": len(suspicious_activity.get("alerts", [])),
                    }

                elif operation == "block":
                    if not ip_address:
                        raise TailscaleMCPError("ip_address is required for block operation")
                    result = await self.device_manager.block_malicious_ip(ip_address, block_duration)
                    return {
                        "operation": "block",
                        "ip_address": ip_address,
                        "block_duration": block_duration,
                        "result": result,
                    }

                elif operation == "quarantine":
                    if not device_id:
                        raise TailscaleMCPError("device_id is required for quarantine operation")
                    result = await self.device_manager.quarantine_device(device_id, quarantine_duration)
                    return {
                        "operation": "quarantine",
                        "device_id": device_id,
                        "quarantine_duration": quarantine_duration,
                        "result": result,
                    }

                elif operation == "alert":
                    if not alert_message:
                        raise TailscaleMCPError("alert_message is required for alert operation")
                    result = await self.device_manager.alert_on_breach(alert_severity, alert_message)
                    return {
                        "operation": "alert",
                        "severity": alert_severity,
                        "message": alert_message,
                        "result": result,
                    }

                elif operation == "policy":
                    if not policy_name or not rules:
                        raise TailscaleMCPError("policy_name and rules are required for policy operation")
                    result = await self.device_manager.create_security_policy(policy_name, rules, priority)
                    return {
                        "operation": "policy_create",
                        "policy_name": policy_name,
                        "rules": rules,
                        "priority": priority,
                        "result": result,
                    }

                elif operation == "threat":
                    if not threat_type:
                        raise TailscaleMCPError("threat_type is required for threat operation")
                    result = await self.device_manager.detect_threat(threat_type, test_mode)
                    return {
                        "operation": "threat_detect",
                        "threat_type": threat_type,
                        "test_mode": test_mode,
                        "result": result,
                    }

                else:
                    raise TailscaleMCPError(f"Unknown operation: {operation}")

            except Exception as e:
                logger.error("Error in tailscale_security operation", operation=operation, error=str(e))
                raise TailscaleMCPError(f"Failed to perform security operation: {e}") from e

        @self.mcp.tool()
        async def tailscale_automation(
            operation: str,
            workflow_name: str | None = None,
            workflow_steps: list[dict[str, Any]] | None = None,
            schedule_cron: str | None = None,
            script_content: str | None = None,
            script_language: str = "python",
            template_name: str | None = None,
            batch_operations: list[dict[str, Any]] | None = None,
            dry_run: bool = False,
            execute_now: bool = False,
            workflow_id: str | None = None,
        ) -> dict[str, Any]:
            """Comprehensive workflow automation, script execution, and batch operation management.

            This portmanteau tool provides complete automation capabilities for Tailscale tailnet management,
            including workflow creation and execution, script automation, and batch operations. It consolidates
            9 operations for automating repetitive tasks and complex workflows.

            PORTMANTEAU PATTERN RATIONALE:
            Instead of creating 9 separate tools (one per operation), this tool consolidates related
            automation and workflow operations into a single interface. This design:
            - Prevents tool explosion (9 tools → 1 tool) while maintaining full functionality
            - Improves discoverability by grouping related operations together
            - Reduces cognitive load when working with automation tasks
            - Enables atomic batch operations across multiple automation/workflow actions
            - Follows FastMCP 2.12+ best practices for feature-rich MCP servers

            The 'operation' parameter determines which specific action to perform, while other parameters
            are operation-specific. This pattern is used throughout the Tailscale MCP server for all
            major feature areas (device, network, security, etc.).

            Use this tool to create reusable workflows, execute scripts, perform batch operations, and automate
            routine Tailscale management tasks. All operations support dry-run mode for safe testing and
            scheduling for automated execution.

            SUPPORTED OPERATIONS:

            Workflow Management:
            - workflow_create: Create a new automation workflow with defined steps.
              Workflows are sequences of operations that can be executed together.

            - workflow_execute: Execute a workflow immediately or on schedule.
              Runs all steps in the workflow in sequence with error handling.

            - workflow_schedule: Schedule a workflow to run automatically on a cron schedule.
              Sets up recurring execution of workflows for automated operations.

            - workflow_list: List all defined workflows with their status and metadata.
              Shows all workflows including their steps, schedules, and execution history.

            - workflow_delete: Delete a workflow and its configuration.
              Permanently removes a workflow from the system.

            Script Execution:
            - script_execute: Execute a custom script in the specified language.
              Runs scripts for automation tasks with proper error handling and logging.

            - script_template: Get a script template for common automation tasks.
              Retrieves pre-built script templates for quick automation setup.

            Batch Operations:
            - batch: Execute multiple operations in a single batch for efficiency.
              Performs multiple operations atomically with rollback on failure.

            - dry_run: Preview operations without executing them.
              Shows what operations would do without making actual changes.

            Args:
                operation: Operation to perform. MUST be one of:
                    - "workflow_create": Create automation workflow
                    - "workflow_execute": Execute workflow
                    - "workflow_schedule": Schedule workflow execution
                    - "workflow_list": List all workflows
                    - "workflow_delete": Delete workflow
                    - "script_execute": Execute custom script
                    - "script_template": Get script template
                    - "batch": Perform batch operations
                    - "dry_run": Preview operations

                workflow_name (str | None): Workflow name identifier. Required for: workflow_create operation. Example: "daily-device-audit"
                workflow_steps (list[dict[str, Any]] | None): List of workflow step dictionaries. Required for: workflow_create operation.
                    Each step dict must contain: "tool" (str, tool name), "operation" (str, operation name).
                    Steps execute sequentially. Example: [{"tool": "tailscale_device", "operation": "list"}, {"tool": "tailscale_security", "operation": "scan"}]
                schedule_cron (str | None): Cron expression for scheduling. Required for: workflow_schedule operation.
                    Format: "minute hour day month weekday" (5 fields, space-separated). Use "*" for any value.
                    Example: "0 2 * * *" (daily at 2 AM), "0 */6 * * *" (every 6 hours)
                script_content (str | None): Script code to execute. Required for: script_execute operation. Example: "print('Hello, Tailscale!')"
                script_language (str): Script language. Used by: script_execute operation. Valid: "python", "bash", "powershell". Default: "python"
                template_name (str | None): Script template name. Required for: script_template operation. Example: "device-audit-template"
                batch_operations (list[dict[str, Any]] | None): List of operations to execute. Required for: batch, dry_run operations.
                    Each operation dict contains: "tool" (str), "operation" (str), plus operation-specific parameters.
                    All operations execute atomically (all succeed or all fail). Example: [{"tool": "tailscale_device", "operation": "list"}, {"tool": "tailscale_network", "operation": "dns_config"}]
                dry_run (bool): Preview mode without execution. Used by: script_execute, batch operations. Default: False
                execute_now (bool): Execute immediately. Used by: workflow_execute operation. Default: False
                workflow_id (str | None): Workflow identifier. Required for: workflow_execute, workflow_schedule, workflow_delete operations. Example: "workflow-abc123"

            Returns:
                Dictionary containing operation results. Structure varies by operation:

                For "workflow_create" operation:
                    {
                        "operation": "workflow_create",
                        "workflow_name": str,
                        "workflow_id": str,
                        "steps_count": int,
                        "result": {workflow dictionary}
                    }

                For "workflow_execute" operation:
                    {
                        "operation": "workflow_execute",
                        "workflow_id": str,
                        "execute_now": bool,
                        "result": {
                            "execution_id": str,
                            "status": "running" | "completed" | "failed",
                            "steps_completed": int,
                            ...
                        }
                    }

                For "workflow_schedule" operation:
                    {
                        "operation": "workflow_schedule",
                        "workflow_id": str,
                        "schedule_cron": str,
                        "result": {"scheduled": True, "next_run": float}
                    }

                For "workflow_list" operation:
                    {
                        "operation": "workflow_list",
                        "workflows": [list of workflow dictionaries],
                        "count": int
                    }

                For "workflow_delete" operation:
                    {
                        "operation": "workflow_delete",
                        "workflow_id": str,
                        "result": {"deleted": True}
                    }

                For "script_execute" operation:
                    {
                        "operation": "script_execute",
                        "script_language": str,
                        "dry_run": bool,
                        "result": {
                            "output": str,
                            "exit_code": int,
                            "execution_time": float,
                            ...
                        }
                    }

                For "script_template" operation:
                    {
                        "operation": "script_template",
                        "template_name": str,
                        "template": {template dictionary with content}
                    }

                For "batch" operation:
                    {
                        "operation": "batch",
                        "operations_count": int,
                        "dry_run": bool,
                        "result": {
                            "completed": int,
                            "failed": int,
                            "results": [list of operation results],
                            ...
                        }
                    }

                For "dry_run" operation:
                    {
                        "operation": "dry_run",
                        "preview": {
                            "operations": [list of operations that would execute],
                            "estimated_time": float,
                            "changes_summary": str,
                            ...
                        },
                        "operations_count": int
                    }

            Raises:
                TailscaleMCPError: If operation fails, invalid parameters provided, or execution fails.
                    Common causes: missing required parameters, invalid workflow steps, script execution error.

                ValueError: If parameter validation fails (e.g., invalid cron expression, invalid script language).

                SyntaxError: If script_content contains syntax errors for the specified language.

            Usage:
                This tool enables automation of repetitive Tailscale management tasks and complex workflows.
                Use it to create reusable automation, execute scripts, and perform batch operations efficiently.

                Common workflows:
                - Daily automation: Create workflow with "workflow_create", then schedule with "workflow_schedule"
                - Script automation: Use "script_template" to get template, customize, then "script_execute"
                - Batch operations: Use "batch" to execute multiple operations atomically
                - Safe testing: Use "dry_run" to preview operations before execution
                - Workflow management: Use "workflow_list" to see workflows, "workflow_execute" to run

                Best practices:
                - Always test workflows with "dry_run" before scheduling
                - Use descriptive workflow names for easy identification
                - Break complex workflows into smaller, testable steps
                - Schedule workflows during off-peak hours when possible
                - Monitor workflow execution for errors
                - Use batch operations for atomic multi-step changes
                - Document workflow purposes and expected outcomes

            Examples:
                Create workflow:
                    result = await tailscale_automation(
                        operation="workflow_create",
                        workflow_name="daily-security-scan",
                        workflow_steps=[
                            {"tool": "tailscale_device", "operation": "list"},
                            {"tool": "tailscale_security", "operation": "scan"}
                        ]
                    )
                    # Returns workflow with ID

                Execute workflow:
                    result = await tailscale_automation(
                        operation="workflow_execute",
                        workflow_id="workflow-abc123",
                        execute_now=True
                    )
                    # Returns execution results

                Schedule workflow:
                    result = await tailscale_automation(
                        operation="workflow_schedule",
                        workflow_id="workflow-abc123",
                        schedule_cron="0 2 * * *"
                    )
                    # Returns schedule confirmation

                List workflows:
                    result = await tailscale_automation(operation="workflow_list")
                    # Returns all workflows

                Execute script:
                    result = await tailscale_automation(
                        operation="script_execute",
                        script_content="print('Automation script')",
                        script_language="python",
                        dry_run=False
                    )
                    # Returns script execution results

                Get script template:
                    result = await tailscale_automation(
                        operation="script_template",
                        template_name="device-audit-template"
                    )
                    # Returns template content

                Batch operations:
                    result = await tailscale_automation(
                        operation="batch",
                        batch_operations=[
                            {"tool": "tailscale_device", "operation": "list"},
                            {"tool": "tailscale_network", "operation": "dns_config"}
                        ],
                        dry_run=False
                    )
                    # Returns batch execution results

                Preview operations:
                    result = await tailscale_automation(
                        operation="dry_run",
                        batch_operations=[...]
                    )
                    # Returns preview of operations

                Error handling:
                    try:
                        result = await tailscale_automation(
                            operation="workflow_execute",
                            workflow_id="nonexistent"
                        )
                    except TailscaleMCPError as e:
                        print(f"Workflow execution failed: {e}")
                    # Handles errors gracefully

            Notes:
                - Workflows execute steps sequentially with error handling
                - Scheduled workflows run automatically based on cron expression
                - Scripts run in isolated execution environment
                - Batch operations are atomic (all succeed or all fail)
                - Dry-run mode shows operations without making changes
                - Workflow execution history is logged for audit
                - Script templates provide starting points for common tasks
                - Cron expressions use standard 5-field format
                - Related tools: tailscale_device, tailscale_security (for workflow steps)
"""
            try:
                if operation == "workflow_create":
                    if not workflow_name or not workflow_steps:
                        raise TailscaleMCPError("workflow_name and workflow_steps are required for workflow_create operation")
                    result = await self.device_manager.create_workflow(workflow_name, workflow_steps)
                    return {
                        "operation": "workflow_create",
                        "workflow_name": workflow_name,
                        "workflow_id": result.get("workflow_id"),
                        "steps_count": len(workflow_steps),
                        "result": result,
                    }

                elif operation == "workflow_execute":
                    if not workflow_id:
                        raise TailscaleMCPError("workflow_id is required for workflow_execute operation")
                    result = await self.device_manager.execute_workflow(workflow_id, execute_now)
                    return {
                        "operation": "workflow_execute",
                        "workflow_id": workflow_id,
                        "execute_now": execute_now,
                        "result": result,
                    }

                elif operation == "workflow_schedule":
                    if not workflow_id or not schedule_cron:
                        raise TailscaleMCPError("workflow_id and schedule_cron are required for workflow_schedule operation")
                    result = await self.device_manager.schedule_workflow(workflow_id, schedule_cron)
                    return {
                        "operation": "workflow_schedule",
                        "workflow_id": workflow_id,
                        "schedule_cron": schedule_cron,
                        "result": result,
                    }

                elif operation == "workflow_list":
                    workflows = await self.device_manager.list_workflows()
                    return {
                        "operation": "workflow_list",
                        "workflows": workflows,
                        "count": len(workflows),
                    }

                elif operation == "workflow_delete":
                    if not workflow_id:
                        raise TailscaleMCPError("workflow_id is required for workflow_delete operation")
                    result = await self.device_manager.delete_workflow(workflow_id)
                    return {
                        "operation": "workflow_delete",
                        "workflow_id": workflow_id,
                        "result": result,
                    }

                elif operation == "script_execute":
                    if not script_content:
                        raise TailscaleMCPError("script_content is required for script_execute operation")
                    result = await self.device_manager.execute_script(script_content, script_language, dry_run)
                    return {
                        "operation": "script_execute",
                        "script_language": script_language,
                        "dry_run": dry_run,
                        "result": result,
                    }

                elif operation == "script_template":
                    if not template_name:
                        raise TailscaleMCPError("template_name is required for script_template operation")
                    template = await self.device_manager.get_script_template(template_name)
                    return {
                        "operation": "script_template",
                        "template_name": template_name,
                        "template": template,
                    }

                elif operation == "batch":
                    if not batch_operations:
                        raise TailscaleMCPError("batch_operations is required for batch operation")
                    result = await self.device_manager.batch_operations(batch_operations, dry_run)
                    return {
                        "operation": "batch",
                        "operations_count": len(batch_operations),
                        "dry_run": dry_run,
                        "result": result,
                    }

                elif operation == "dry_run":
                    if not batch_operations:
                        raise TailscaleMCPError("batch_operations is required for dry_run operation")
                    preview = await self.device_manager.preview_operations(batch_operations)
                    return {
                        "operation": "dry_run",
                        "preview": preview,
                        "operations_count": len(batch_operations),
                    }

                else:
                    raise TailscaleMCPError(f"Unknown operation: {operation}")

            except Exception as e:
                logger.error("Error in tailscale_automation operation", operation=operation, error=str(e))
                raise TailscaleMCPError(f"Failed to perform automation operation: {e}") from e

        @self.mcp.tool()
        async def tailscale_backup(
            operation: str,
            backup_name: str | None = None,
            backup_type: str = "full",
            include_devices: bool = True,
            include_policies: bool = True,
            include_users: bool = True,
            restore_point: str | None = None,  # noqa: ARG001
            backup_id: str | None = None,
            schedule_cron: str | None = None,
            retention_days: int = 30,
            compression: bool = True,
            encryption: bool = True,
            test_restore: bool = False,
        ) -> dict[str, Any]:
            """Comprehensive backup, restore, and disaster recovery operations for Tailscale configurations.

            This portmanteau tool provides complete backup and disaster recovery capabilities for Tailscale
            tailnet configurations, including automated backups, restore operations, integrity testing, and
            disaster recovery planning. It consolidates 8 operations for comprehensive data protection.

            PORTMANTEAU PATTERN RATIONALE:
            Instead of creating 8 separate tools (one per operation), this tool consolidates related
            backup and recovery operations into a single interface. This design:
            - Prevents tool explosion (8 tools → 1 tool) while maintaining full functionality
            - Improves discoverability by grouping related operations together
            - Reduces cognitive load when working with backup/recovery tasks
            - Enables atomic batch operations across multiple backup/recovery actions
            - Follows FastMCP 2.12+ best practices for feature-rich MCP servers

            The 'operation' parameter determines which specific action to perform, while other parameters
            are operation-specific. This pattern is used throughout the Tailscale MCP server for all
            major feature areas (device, network, security, etc.).

            Use this tool to create backups of device configurations, policies, and user accounts; restore
            from backups; schedule automated backups; and create disaster recovery plans. All backups support
            compression and encryption for secure storage.

            SUPPORTED OPERATIONS:

            Backup Management:
            - backup_create: Create a backup of tailnet configuration.
              Backs up devices, policies, users, and other configuration data.

            - backup_list: List all available backups with metadata.
              Shows all backups including creation date, size, type, and status.

            - backup_delete: Delete a backup from the system.
              Permanently removes a backup and frees storage space.

            - backup_test: Test backup integrity and verify backup is valid.
              Validates backup file integrity and checks for corruption.

            Restore Operations:
            - backup_restore: Restore tailnet configuration from a backup.
              Restores devices, policies, users, and other configuration from backup.

            - restore_test: Test restore procedure without applying changes.
              Validates restore process and shows what would be restored.

            Automation & Planning:
            - backup_schedule: Schedule automated backups on a recurring schedule.
              Sets up automatic backups using cron expression for regular protection.

            - recovery_plan: Generate disaster recovery plan with procedures and documentation.
              Creates comprehensive recovery plan with step-by-step procedures.

            Args:
                operation: Operation to perform. MUST be one of:
                    - "backup_create": Create configuration backup
                    - "backup_restore": Restore from backup
                    - "backup_schedule": Schedule automated backups
                    - "backup_list": List all backups
                    - "backup_delete": Delete backup
                    - "backup_test": Test backup integrity
                    - "restore_test": Test restore procedure
                    - "recovery_plan": Create disaster recovery plan

                backup_name (str | None): Backup name identifier. Required for: backup_create operation. Example: "daily-backup-2025-01-27"
                backup_type (str): Type of backup. Used by: backup_create operation. Valid: "full", "incremental", "differential". Default: "full"
                include_devices (bool): Include device configurations. Used by: backup_create operation. Default: True
                include_policies (bool): Include ACL policies. Used by: backup_create operation. Default: True
                include_users (bool): Include user accounts. Used by: backup_create operation. Default: True
                restore_point (str | None): Restore point identifier. Currently unused but reserved.
                backup_id (str | None): Backup identifier. Required for: backup_restore, backup_delete, backup_test, restore_test operations. Example: "backup-abc123"
                schedule_cron (str | None): Cron expression for scheduling. Required for: backup_schedule operation. Example: "0 3 * * *" (daily at 3 AM)
                retention_days (int): Backup retention period in days. Used by: backup_schedule operation. Range: 1-365. Default: 30
                compression (bool): Enable backup compression. Used by: backup_create operation. Default: True
                encryption (bool): Enable backup encryption. Used by: backup_create operation. Default: True
                test_restore (bool): Test restore without applying. Used by: backup_restore operation. Default: False

            Returns:
                Dictionary containing operation results. Structure varies by operation:

                For "backup_create" operation:
                    {
                        "operation": "backup_create",
                        "backup_name": str,
                        "backup_type": str,
                        "backup_id": str,
                        "result": {
                            "backup_id": str,
                            "size_bytes": int,
                            "created_at": float,
                            "includes": {
                                "devices": bool,
                                "policies": bool,
                                "users": bool
                            },
                            ...
                        }
                    }

                For "backup_restore" operation:
                    {
                        "operation": "backup_restore",
                        "backup_id": str,
                        "test_restore": bool,
                        "result": {
                            "restored": True,
                            "items_restored": {
                                "devices": int,
                                "policies": int,
                                "users": int
                            },
                            ...
                        }
                    }

                For "backup_schedule" operation:
                    {
                        "operation": "backup_schedule",
                        "schedule_cron": str,
                        "retention_days": int,
                        "result": {
                            "scheduled": True,
                            "next_backup": float,
                            "retention_days": int,
                            ...
                        }
                    }

                For "backup_list" operation:
                    {
                        "operation": "backup_list",
                        "backups": [list of backup dictionaries],
                        "count": int
                    }

                For "backup_delete" operation:
                    {
                        "operation": "backup_delete",
                        "backup_id": str,
                        "result": {"deleted": True}
                    }

                For "backup_test" operation:
                    {
                        "operation": "backup_test",
                        "backup_id": str,
                        "result": {
                            "valid": bool,
                            "integrity_check": "passed" | "failed",
                            "size_bytes": int,
                            "corruption_detected": bool,
                            ...
                        }
                    }

                For "restore_test" operation:
                    {
                        "operation": "restore_test",
                        "backup_id": str,
                        "result": {
                            "would_restore": {
                                "devices": int,
                                "policies": int,
                                "users": int
                            },
                            "conflicts": [list of conflicts],
                            ...
                        }
                    }

                For "recovery_plan" operation:
                    {
                        "operation": "recovery_plan",
                        "result": {
                            "plan": {recovery plan document},
                            "procedures": [list of procedures],
                            "checklist": [list of checklist items],
                            ...
                        }
                    }

            Raises:
                TailscaleMCPError: If operation fails, invalid parameters provided, or backup/restore fails.
                    Common causes: missing required parameters, backup not found, restore conflicts.

                ValueError: If parameter validation fails (e.g., invalid retention_days, invalid cron expression).

                BackupCorruptionError: If backup file is corrupted or invalid.

            Usage:
                This tool is essential for data protection and disaster recovery in Tailscale tailnets.
                Use it to create regular backups, restore from backups, and plan for disaster recovery.

                Common workflows:
                - Regular backups: Use "backup_create" for manual backups, "backup_schedule" for automated
                - Backup verification: Use "backup_test" to verify backup integrity
                - Disaster recovery: Use "recovery_plan" to create plan, then "backup_restore" to recover
                - Backup management: Use "backup_list" to see backups, "backup_delete" to clean up old ones
                - Safe restore: Use "restore_test" to preview restore, then "backup_restore" to apply

                Best practices:
                - Create backups regularly (daily or weekly depending on change frequency)
                - Schedule automated backups for consistent protection
                - Test backup integrity regularly with "backup_test"
                - Test restore procedures periodically with "restore_test"
                - Keep multiple backup generations for recovery options
                - Use encryption for sensitive configuration backups
                - Document recovery procedures using "recovery_plan"
                - Set appropriate retention periods based on compliance requirements

            Examples:
                Create backup:
                    result = await tailscale_backup(
                        operation="backup_create",
                        backup_name="daily-backup-2025-01-27",
                        backup_type="full",
                        include_devices=True,
                        include_policies=True,
                        include_users=True,
                        compression=True,
                        encryption=True
                    )
                    # Returns: {
                    #     "operation": "backup_create",
                    #     "backup_id": "backup-abc123",
                    #     ...
                    # }

                List backups:
                    result = await tailscale_backup(operation="backup_list")
                    # Returns all available backups

                Test backup integrity:
                    result = await tailscale_backup(
                        operation="backup_test",
                        backup_id="backup-abc123"
                    )
                    # Returns integrity test results

                Test restore:
                    result = await tailscale_backup(
                        operation="restore_test",
                        backup_id="backup-abc123"
                    )
                    # Returns restore preview

                Restore from backup:
                    result = await tailscale_backup(
                        operation="backup_restore",
                        backup_id="backup-abc123",
                        test_restore=False
                    )
                    # Returns restore confirmation

                Schedule automated backups:
                    result = await tailscale_backup(
                        operation="backup_schedule",
                        schedule_cron="0 3 * * *",
                        retention_days=90
                    )
                    # Returns schedule confirmation

                Create recovery plan:
                    result = await tailscale_backup(operation="recovery_plan")
                    # Returns disaster recovery plan

                Delete backup:
                    result = await tailscale_backup(
                        operation="backup_delete",
                        backup_id="backup-abc123"
                    )
                    # Returns deletion confirmation

                Error handling:
                    try:
                        result = await tailscale_backup(
                            operation="backup_restore",
                            backup_id="nonexistent"
                        )
                    except TailscaleMCPError as e:
                        print(f"Restore failed: {e}")
                    # Handles missing backup gracefully

            Notes:
                - Full backups contain complete configuration, incremental/differential contain changes only
                - Encrypted backups require decryption key for restore
                - Compressed backups save space but may take longer to create/restore
                - Scheduled backups run automatically and follow retention policy
                - Restore operations may overwrite existing configuration
                - Always test restore procedures before actual disaster recovery
                - Backup integrity should be verified regularly
                - Recovery plans should be reviewed and updated periodically
                - Related tools: tailscale_device (for device management), tailscale_network (for network config)
"""
            try:
                if operation == "backup_create":
                    if not backup_name:
                        raise TailscaleMCPError("backup_name is required for backup_create operation")
                    result = await self.device_manager.create_backup(
                        backup_name, backup_type, include_devices, include_policies,
                        include_users, compression, encryption
                    )
                    return {
                        "operation": "backup_create",
                        "backup_name": backup_name,
                        "backup_type": backup_type,
                        "backup_id": result.get("backup_id"),
                        "result": result,
                    }

                elif operation == "backup_restore":
                    if not backup_id:
                        raise TailscaleMCPError("backup_id is required for backup_restore operation")
                    result = await self.device_manager.restore_backup(backup_id, test_restore)
                    return {
                        "operation": "backup_restore",
                        "backup_id": backup_id,
                        "test_restore": test_restore,
                        "result": result,
                    }

                elif operation == "backup_schedule":
                    if not schedule_cron:
                        raise TailscaleMCPError("schedule_cron is required for backup_schedule operation")
                    result = await self.device_manager.schedule_backups(schedule_cron, retention_days)
                    return {
                        "operation": "backup_schedule",
                        "schedule_cron": schedule_cron,
                        "retention_days": retention_days,
                        "result": result,
                    }

                elif operation == "backup_list":
                    backups = await self.device_manager.list_backups()
                    return {
                        "operation": "backup_list",
                        "backups": backups,
                        "count": len(backups),
                    }

                elif operation == "backup_delete":
                    if not backup_id:
                        raise TailscaleMCPError("backup_id is required for backup_delete operation")
                    result = await self.device_manager.delete_backup(backup_id)
                    return {
                        "operation": "backup_delete",
                        "backup_id": backup_id,
                        "result": result,
                    }

                elif operation == "backup_test":
                    if not backup_id:
                        raise TailscaleMCPError("backup_id is required for backup_test operation")
                    result = await self.device_manager.test_backup_integrity(backup_id)
                    return {
                        "operation": "backup_test",
                        "backup_id": backup_id,
                        "result": result,
                    }

                elif operation == "restore_test":
                    if not backup_id:
                        raise TailscaleMCPError("backup_id is required for restore_test operation")
                    result = await self.device_manager.test_restore_procedure(backup_id)
                    return {
                        "operation": "restore_test",
                        "backup_id": backup_id,
                        "result": result,
                    }

                elif operation == "recovery_plan":
                    result = await self.device_manager.create_recovery_plan()
                    return {
                        "operation": "recovery_plan",
                        "result": result,
                    }

                else:
                    raise TailscaleMCPError(f"Unknown operation: {operation}")

            except Exception as e:
                logger.error("Error in tailscale_backup operation", operation=operation, error=str(e))
                raise TailscaleMCPError(f"Failed to perform backup operation: {e}") from e

        @self.mcp.tool()
        async def tailscale_performance(
            operation: str,
            device_id: str | None = None,
            measure_duration: int = 60,
            bandwidth_test: bool = False,  # noqa: ARG001
            latency_test: bool = False,  # noqa: ARG001
            route_optimization: bool = False,
            baseline_name: str | None = None,
            baseline_duration: int = 300,
            capacity_period: str = "30d",
            scaling_factor: float = 1.2,
            performance_threshold: float = 0.8,
        ) -> dict[str, Any]:
            """Comprehensive performance monitoring, analysis, and optimization operations for Tailscale networks.

            This portmanteau tool provides complete performance management capabilities including latency measurement,
            bandwidth analysis, routing optimization, baseline establishment, capacity planning, and scaling
            recommendations. It consolidates 8 operations for comprehensive network performance management.

            PORTMANTEAU PATTERN RATIONALE:
            Instead of creating 8 separate tools (one per operation), this tool consolidates related
            performance monitoring and optimization operations into a single interface. This design:
            - Prevents tool explosion (8 tools → 1 tool) while maintaining full functionality
            - Improves discoverability by grouping related operations together
            - Reduces cognitive load when working with performance tasks
            - Enables atomic batch operations across multiple performance/optimization actions
            - Follows FastMCP 2.12+ best practices for feature-rich MCP servers

            The 'operation' parameter determines which specific action to perform, while other parameters
            are operation-specific. This pattern is used throughout the Tailscale MCP server for all
            major feature areas (device, network, security, etc.).

            Use this tool to measure network performance, identify bottlenecks, optimize routing, establish
            performance baselines, predict capacity needs, and get scaling recommendations. All operations
            provide actionable insights for network optimization.

            SUPPORTED OPERATIONS:

            Performance Measurement:
            - latency: Measure network latency between devices or to specific targets.
              Measures round-trip time, packet loss, and jitter for performance analysis.

            - bandwidth: Analyze bandwidth utilization and throughput.
              Measures bandwidth usage, identifies bottlenecks, and analyzes traffic patterns.

            Optimization:
            - optimize: Optimize routing performance for better network efficiency.
              Analyzes routing paths and suggests optimizations for improved performance.

            Baseline & Capacity Planning:
            - baseline: Establish performance baselines for comparison and monitoring.
              Creates baseline metrics for tracking performance changes over time.

            - capacity: Predict capacity requirements based on current usage and trends.
              Analyzes usage patterns and predicts future capacity needs.

            Resource Analysis:
            - utilization: Analyze resource utilization across the network.
              Measures device and network resource usage for optimization opportunities.

            - scaling: Get scaling recommendations based on current performance and capacity.
              Provides recommendations for scaling network resources to meet demand.

            - threshold: Set performance thresholds for alerting and monitoring.
              Defines performance thresholds for automated alerting when exceeded.

            Args:
                operation: Operation to perform. MUST be one of:
                    - "latency": Measure network latency
                    - "bandwidth": Analyze bandwidth utilization
                    - "optimize": Optimize routing performance
                    - "baseline": Establish performance baselines
                    - "capacity": Predict capacity requirements
                    - "utilization": Analyze resource utilization
                    - "scaling": Get scaling recommendations
                    - "threshold": Set performance thresholds

                device_id (str | None): Device identifier. Optional for: latency, bandwidth, utilization operations. If not specified, measures all devices. Example: "device123"
                measure_duration (int): Measurement duration in seconds. Used by: latency, bandwidth operations. Range: 10-3600. Default: 60
                bandwidth_test (bool): Enable bandwidth testing. Currently unused but reserved. Default: False
                latency_test (bool): Enable latency testing. Currently unused but reserved. Default: False
                route_optimization (bool): Enable route optimization. Used by: optimize operation. Default: False
                baseline_name (str | None): Baseline name identifier. Required for: baseline operation. Example: "production-baseline-2025"
                baseline_duration (int): Baseline measurement duration in seconds. Used by: baseline operation. Range: 60-3600. Default: 300
                capacity_period (str): Period for capacity prediction. Used by: capacity operation. Default: "30d".
                    Valid: "7d" (7 days), "30d" (30 days), "90d" (90 days), "180d" (6 months), "1y" (1 year).
                    Longer periods provide more accurate predictions but require more historical data
                scaling_factor (float): Scaling factor multiplier. Used by: scaling operation. Range: 1.0-5.0. Default: 1.2
                performance_threshold (float): Performance threshold percentage. Used by: threshold operation. Range: 0.0-1.0. Default: 0.8

            Returns:
                Dictionary containing operation results. Structure varies by operation:

                For "latency" operation:
                    {
                        "operation": "latency",
                        "device_id": str | None,
                        "duration": int,
                        "results": {
                            "average_latency_ms": float,
                            "min_latency_ms": float,
                            "max_latency_ms": float,
                            "packet_loss_percent": float,
                            "jitter_ms": float,
                            ...
                        }
                    }

                For "bandwidth" operation:
                    {
                        "operation": "bandwidth",
                        "device_id": str | None,
                        "duration": int,
                        "results": {
                            "bandwidth_utilization_percent": float,
                            "throughput_mbps": float,
                            "bottlenecks": [list of bottlenecks],
                            ...
                        }
                    }

                For "optimize" operation:
                    {
                        "operation": "optimize",
                        "route_optimization": bool,
                        "results": {
                            "optimizations_applied": [list of optimizations],
                            "performance_improvement_percent": float,
                            ...
                        }
                    }

                For "baseline" operation:
                    {
                        "operation": "baseline",
                        "baseline_name": str,
                        "duration": int,
                        "results": {
                            "baseline_id": str,
                            "metrics": {baseline metrics},
                            "created_at": float,
                            ...
                        }
                    }

                For "capacity" operation:
                    {
                        "operation": "capacity",
                        "capacity_period": str,
                        "results": {
                            "current_capacity": float,
                            "predicted_capacity": float,
                            "recommendations": [list of recommendations],
                            ...
                        }
                    }

                For "utilization" operation:
                    {
                        "operation": "utilization",
                        "device_id": str | None,
                        "results": {
                            "cpu_utilization_percent": float,
                            "memory_utilization_percent": float,
                            "network_utilization_percent": float,
                            ...
                        }
                    }

                For "scaling" operation:
                    {
                        "operation": "scaling",
                        "scaling_factor": float,
                        "recommendations": {
                            "recommended_scaling": float,
                            "current_resources": int,
                            "recommended_resources": int,
                            ...
                        }
                    }

                For "threshold" operation:
                    {
                        "operation": "threshold",
                        "threshold": float,
                        "results": {
                            "threshold_set": True,
                            "threshold_value": float,
                            ...
                        }
                    }

            Raises:
                TailscaleMCPError: If operation fails, invalid parameters provided, or measurement fails.
                    Common causes: missing required parameters, device not found, measurement timeout.

                ValueError: If parameter validation fails (e.g., invalid duration, invalid threshold).

            Usage:
                This tool is essential for performance monitoring and optimization in Tailscale tailnets.
                Use it to measure performance, identify issues, optimize routing, and plan for capacity.

                Common workflows:
                - Performance monitoring: Use "latency" and "bandwidth" to measure current performance
                - Baseline establishment: Use "baseline" to create performance baselines for comparison
                - Optimization: Use "optimize" to improve routing, then measure with "latency" to verify
                - Capacity planning: Use "capacity" to predict needs, then "scaling" for recommendations
                - Resource management: Use "utilization" to identify bottlenecks, then optimize
                - Alerting: Use "threshold" to set performance thresholds for automated monitoring

                Best practices:
                - Establish baselines before making changes for comparison
                - Measure performance regularly to track trends
                - Use longer measurement durations for more accurate results
                - Compare current performance against baselines
                - Use capacity predictions for planning
                - Set appropriate thresholds for alerting
                - Optimize routing during maintenance windows
                - Monitor utilization to identify optimization opportunities

            Examples:
                Measure latency:
                    result = await tailscale_performance(
                        operation="latency",
                        device_id="device123",
                        measure_duration=120
                    )
                    # Returns latency measurements

                Analyze bandwidth:
                    result = await tailscale_performance(
                        operation="bandwidth",
                        measure_duration=300
                    )
                    # Returns bandwidth analysis

                Optimize routing:
                    result = await tailscale_performance(
                        operation="optimize",
                        route_optimization=True
                    )
                    # Returns optimization results

                Establish baseline:
                    result = await tailscale_performance(
                        operation="baseline",
                        baseline_name="production-baseline",
                        baseline_duration=600
                    )
                    # Returns baseline metrics

                Predict capacity:
                    result = await tailscale_performance(
                        operation="capacity",
                        capacity_period="90d"
                    )
                    # Returns capacity predictions

                Analyze utilization:
                    result = await tailscale_performance(
                        operation="utilization",
                        device_id="device123"
                    )
                    # Returns utilization statistics

                Get scaling recommendations:
                    result = await tailscale_performance(
                        operation="scaling",
                        scaling_factor=1.5
                    )
                    # Returns scaling recommendations

                Set performance threshold:
                    result = await tailscale_performance(
                        operation="threshold",
                        performance_threshold=0.9
                    )
                    # Returns threshold configuration

                Error handling:
                    try:
                        result = await tailscale_performance(
                            operation="baseline",
                            baseline_name="test"
                        )
                    except TailscaleMCPError as e:
                        print(f"Performance operation failed: {e}")
                    # Handles errors gracefully

            Notes:
                - Performance measurements may take time depending on duration and network size
                - Baselines should be established during normal operation periods
                - Capacity predictions are based on historical data and trends
                - Routing optimizations may temporarily affect network performance
                - Thresholds trigger alerts when performance degrades below threshold
                - Utilization analysis helps identify resource constraints
                - Scaling recommendations consider current capacity and predicted demand
                - Related tools: tailscale_monitor (for monitoring), tailscale_reporting (for performance reports)
"""
            try:
                if operation == "latency":
                    latency_results = await self.monitor.measure_latency(device_id, measure_duration)
                    return {
                        "operation": "latency",
                        "device_id": device_id,
                        "duration": measure_duration,
                        "results": latency_results,
                    }

                elif operation == "bandwidth":
                    bandwidth_results = await self.monitor.bandwidth_analysis(device_id, measure_duration)
                    return {
                        "operation": "bandwidth",
                        "device_id": device_id,
                        "duration": measure_duration,
                        "results": bandwidth_results,
                    }

                elif operation == "optimize":
                    optimization_results = await self.monitor.optimize_routing(route_optimization)
                    return {
                        "operation": "optimize",
                        "route_optimization": route_optimization,
                        "results": optimization_results,
                    }

                elif operation == "baseline":
                    if not baseline_name:
                        raise TailscaleMCPError("baseline_name is required for baseline operation")
                    baseline_results = await self.monitor.performance_baseline(baseline_name, baseline_duration)
                    return {
                        "operation": "baseline",
                        "baseline_name": baseline_name,
                        "duration": baseline_duration,
                        "results": baseline_results,
                    }

                elif operation == "capacity":
                    capacity_results = await self.monitor.predict_capacity(capacity_period, scaling_factor)
                    return {
                        "operation": "capacity",
                        "period": capacity_period,
                        "scaling_factor": scaling_factor,
                        "results": capacity_results,
                    }

                elif operation == "utilization":
                    utilization_results = await self.monitor.resource_utilization(device_id)
                    return {
                        "operation": "utilization",
                        "device_id": device_id,
                        "results": utilization_results,
                    }

                elif operation == "scaling":
                    scaling_recommendations = await self.monitor.scaling_recommendations(scaling_factor)
                    return {
                        "operation": "scaling",
                        "scaling_factor": scaling_factor,
                        "recommendations": scaling_recommendations,
                    }

                elif operation == "threshold":
                    threshold_results = await self.monitor.set_performance_threshold(performance_threshold)
                    return {
                        "operation": "threshold",
                        "threshold": performance_threshold,
                        "results": threshold_results,
                    }

                else:
                    raise TailscaleMCPError(f"Unknown operation: {operation}")

            except Exception as e:
                logger.error("Error in tailscale_performance operation", operation=operation, error=str(e))
                raise TailscaleMCPError(f"Failed to perform performance operation: {e}") from e

        @self.mcp.tool()
        async def tailscale_reporting(
            operation: str,
            report_type: str = "usage",
            report_format: str = "json",
            date_range: str = "30d",
            include_charts: bool = True,
            custom_fields: list[str] | None = None,
            schedule_cron: str | None = None,
            email_recipients: list[str] | None = None,
            export_path: str | None = None,
            template_name: str | None = None,
            analytics_depth: str = "standard",
            security_focus: bool = False,
            user_behavior: bool = False,  # noqa: ARG001
        ) -> dict[str, Any]:
            """Comprehensive reporting and analytics operations.

            This portmanteau tool provides complete reporting and analytics capabilities for Tailscale tailnets,
            including custom report generation, usage analytics, scheduled reports, and deep network analytics.
            It consolidates 9 operations for comprehensive reporting and analytics.

            PORTMANTEAU PATTERN RATIONALE:
            Instead of creating 9 separate tools (one per operation), this tool consolidates related
            reporting and analytics operations into a single interface. This design:
            - Prevents tool explosion (9 tools → 1 tool) while maintaining full functionality
            - Improves discoverability by grouping related operations together
            - Reduces cognitive load when working with reporting tasks
            - Enables atomic batch operations across multiple reporting/analytics actions
            - Follows FastMCP 2.12+ best practices for feature-rich MCP servers

            The 'operation' parameter determines which specific action to perform, while other parameters
            are operation-specific. This pattern is used throughout the Tailscale MCP server for all
            major feature areas (device, network, security, etc.).

            Use this tool to generate reports, analyze usage patterns, schedule automated reports, export
            data in various formats, and perform deep network analytics. All operations provide actionable
            insights for network management and optimization.

            Args:
                operation: Operation to perform (generate, usage, custom, schedule, export, analytics, behavior, security, template)
                report_type: Type of report (usage, security, performance, compliance)
                report_format: Export format (json, csv, pdf, html)
                date_range: Date range for report (7d, 30d, 90d, 1y)
                include_charts: Include visual charts
                custom_fields: Custom fields to include
                schedule_cron: Cron expression for scheduling
                email_recipients: Email recipients for scheduled reports
                export_path: Path for export operations
                template_name: Template name for template operations
                analytics_depth: Analytics depth (quick, standard, comprehensive)
                security_focus: Focus on security metrics
                user_behavior: Include user behavior analysis

            Returns:
                Operation result with reporting information

            Raises:
                TailscaleMCPError: If operation fails
            """
            try:
                if operation == "generate":
                    report = await self.monitor.generate_usage_report(report_type, date_range, include_charts)
                    return {
                        "operation": "generate",
                        "report_type": report_type,
                        "date_range": date_range,
                        "report": report,
                    }

                elif operation == "usage":
                    usage_report = await self.monitor.generate_usage_report("usage", date_range, include_charts)
                    return {
                        "operation": "usage",
                        "date_range": date_range,
                        "report": usage_report,
                    }

                elif operation == "custom":
                    if not custom_fields:
                        raise TailscaleMCPError("custom_fields is required for custom operation")
                    custom_report = await self.monitor.create_custom_report(custom_fields, date_range, report_format)
                    return {
                        "operation": "custom",
                        "custom_fields": custom_fields,
                        "date_range": date_range,
                        "format": report_format,
                        "report": custom_report,
                    }

                elif operation == "schedule":
                    if not schedule_cron:
                        raise TailscaleMCPError("schedule_cron is required for schedule operation")
                    result = await self.monitor.schedule_reports(schedule_cron, email_recipients)
                    return {
                        "operation": "schedule",
                        "schedule_cron": schedule_cron,
                        "email_recipients": email_recipients,
                        "result": result,
                    }

                elif operation == "export":
                    if not export_path:
                        raise TailscaleMCPError("export_path is required for export operation")
                    result = await self.monitor.export_reports(export_path, report_format)
                    return {
                        "operation": "export",
                        "export_path": export_path,
                        "format": report_format,
                        "result": result,
                    }

                elif operation == "analytics":
                    analytics_results = await self.monitor.network_analytics(analytics_depth, date_range)
                    return {
                        "operation": "analytics",
                        "depth": analytics_depth,
                        "date_range": date_range,
                        "results": analytics_results,
                    }

                elif operation == "behavior":
                    behavior_results = await self.monitor.user_behavior_analysis(date_range)
                    return {
                        "operation": "behavior",
                        "date_range": date_range,
                        "results": behavior_results,
                    }

                elif operation == "security":
                    security_results = await self.monitor.security_metrics(date_range, security_focus)
                    return {
                        "operation": "security",
                        "date_range": date_range,
                        "security_focus": security_focus,
                        "results": security_results,
                    }

                elif operation == "template":
                    if not template_name:
                        raise TailscaleMCPError("template_name is required for template operation")
                    template = await self.monitor.get_report_template(template_name)
                    return {
                        "operation": "template",
                        "template_name": template_name,
                        "template": template,
                    }

                else:
                    raise TailscaleMCPError(f"Unknown operation: {operation}")

            except Exception as e:
                logger.error("Error in tailscale_reporting operation", operation=operation, error=str(e))
                raise TailscaleMCPError(f"Failed to perform reporting operation: {e}") from e

        @self.mcp.tool()
        async def tailscale_integration(
            operation: str,
            webhook_url: str | None = None,
            webhook_secret: str | None = None,
            webhook_events: list[str] | None = None,
            integration_type: str | None = None,
            api_endpoint: str | None = None,
            api_key: str | None = None,
            slack_channel: str | None = None,
            discord_webhook: str | None = None,
            pagerduty_key: str | None = None,
            datadog_api_key: str | None = None,
            test_connection: bool = False,
            webhook_id: str | None = None,
        ) -> dict[str, Any]:
            """Comprehensive third-party integration operations.

            This portmanteau tool provides complete third-party integration capabilities for Tailscale tailnets,
            including webhook management, Slack/Discord notifications, PagerDuty alerts, and Datadog monitoring.
            It consolidates 9 operations for comprehensive integration management.

            PORTMANTEAU PATTERN RATIONALE:
            Instead of creating 9 separate tools (one per operation), this tool consolidates related
            integration operations into a single interface. This design:
            - Prevents tool explosion (9 tools → 1 tool) while maintaining full functionality
            - Improves discoverability by grouping related operations together
            - Reduces cognitive load when working with integration tasks
            - Enables atomic batch operations across multiple integration actions
            - Follows FastMCP 2.12+ best practices for feature-rich MCP servers

            The 'operation' parameter determines which specific action to perform, while other parameters
            are operation-specific. This pattern is used throughout the Tailscale MCP server for all
            major feature areas (device, network, security, etc.).

            Use this tool to create webhooks, integrate with third-party services, test connections, and
            manage integration endpoints. All operations support secure authentication and error handling.

            Args:
                operation: Operation to perform (webhook_create, webhook_test, webhook_list, webhook_delete, slack, discord, pagerduty, datadog, test)
                webhook_url: Webhook URL for webhook operations
                webhook_secret: Webhook secret for authentication
                webhook_events: Events to subscribe to
                integration_type: Type of integration
                api_endpoint: API endpoint for integration
                api_key: API key for integration
                slack_channel: Slack channel for notifications
                discord_webhook: Discord webhook URL
                pagerduty_key: PagerDuty integration key
                datadog_api_key: Datadog API key
                test_connection: Test connection without saving
                webhook_id: Webhook ID for specific operations

            Returns:
                Operation result with integration information

            Raises:
                TailscaleMCPError: If operation fails
            """
            try:
                if operation == "webhook_create":
                    if not webhook_url or not webhook_events:
                        raise TailscaleMCPError("webhook_url and webhook_events are required for webhook_create operation")
                    result = await self.device_manager.create_webhook(webhook_url, webhook_secret, webhook_events)
                    return {
                        "operation": "webhook_create",
                        "webhook_url": webhook_url,
                        "webhook_events": webhook_events,
                        "webhook_id": result.get("webhook_id"),
                        "result": result,
                    }

                elif operation == "webhook_test":
                    if not webhook_id:
                        raise TailscaleMCPError("webhook_id is required for webhook_test operation")
                    result = await self.device_manager.test_webhook(webhook_id)
                    return {
                        "operation": "webhook_test",
                        "webhook_id": webhook_id,
                        "result": result,
                    }

                elif operation == "webhook_list":
                    webhooks = await self.device_manager.list_webhooks()
                    return {
                        "operation": "webhook_list",
                        "webhooks": webhooks,
                        "count": len(webhooks),
                    }

                elif operation == "webhook_delete":
                    if not webhook_id:
                        raise TailscaleMCPError("webhook_id is required for webhook_delete operation")
                    result = await self.device_manager.delete_webhook(webhook_id)
                    return {
                        "operation": "webhook_delete",
                        "webhook_id": webhook_id,
                        "result": result,
                    }

                elif operation == "slack":
                    if not slack_channel:
                        raise TailscaleMCPError("slack_channel is required for slack operation")
                    result = await self.device_manager.integrate_slack(slack_channel, api_key)
                    return {
                        "operation": "slack",
                        "slack_channel": slack_channel,
                        "result": result,
                    }

                elif operation == "discord":
                    if not discord_webhook:
                        raise TailscaleMCPError("discord_webhook is required for discord operation")
                    result = await self.device_manager.integrate_discord(discord_webhook)
                    return {
                        "operation": "discord",
                        "discord_webhook": discord_webhook,
                        "result": result,
                    }

                elif operation == "pagerduty":
                    if not pagerduty_key:
                        raise TailscaleMCPError("pagerduty_key is required for pagerduty operation")
                    result = await self.device_manager.integrate_pagerduty(pagerduty_key)
                    return {
                        "operation": "pagerduty",
                        "pagerduty_key": pagerduty_key,
                        "result": result,
                    }

                elif operation == "datadog":
                    if not datadog_api_key:
                        raise TailscaleMCPError("datadog_api_key is required for datadog operation")
                    result = await self.device_manager.integrate_datadog(datadog_api_key, api_endpoint)
                    return {
                        "operation": "datadog",
                        "datadog_api_key": datadog_api_key,
                        "api_endpoint": api_endpoint,
                        "result": result,
                    }

                elif operation == "test":
                    if not integration_type:
                        raise TailscaleMCPError("integration_type is required for test operation")
                    result = await self.device_manager.test_integration(integration_type, api_key, test_connection)
                    return {
                        "operation": "test",
                        "integration_type": integration_type,
                        "test_connection": test_connection,
                        "result": result,
                    }

                else:
                    raise TailscaleMCPError(f"Unknown operation: {operation}")

            except Exception as e:
                logger.error("Error in tailscale_integration operation", operation=operation, error=str(e))
                raise TailscaleMCPError(f"Failed to perform integration operation: {e}") from e

        @self.mcp.tool()
        async def tailscale_help(
            topic: str | None = None,
            level: str = "basic",
            category: str | None = None,
            operation: str | None = None,
            include_examples: bool = True,
        ) -> dict[str, Any]:
            """Comprehensive multilevel help system for Tailscale MCP server.

            This tool provides detailed, contextual help for all operations:
            - overview: Get general overview of available tools
            - tool: Get help for specific tool (tailscale_device, tailscale_network, etc.)
            - operation: Get help for specific operation within a tool
            - examples: Get usage examples
            - troubleshooting: Get troubleshooting guidance
            - api_reference: Get detailed API reference
            - best_practices: Get best practices and recommendations

            Args:
                topic: Help topic (overview, tool, operation, examples, troubleshooting, api_reference, best_practices)
                level: Help detail level (basic, intermediate, advanced, expert)
                category: Tool category (device, network, monitor, file, security, automation, backup, performance, reporting, integration)
                operation: Specific operation name
                include_examples: Whether to include usage examples

            Returns:
                Comprehensive help information with examples and guidance

            Raises:
                TailscaleMCPError: If help topic is not found
            """
            try:
                help_content = await self._generate_help_content(
                    topic, level, category, operation, include_examples
                )
                return {
                    "topic": topic or "overview",
                    "level": level,
                    "category": category,
                    "operation": operation,
                    "content": help_content,
                    "generated_at": time.time(),
                }

            except Exception as e:
                logger.error("Error generating help content", topic=topic, error=str(e))
                raise TailscaleMCPError(f"Failed to generate help content: {e}") from e

        @self.mcp.tool()
        async def tailscale_status(
            component: str | None = None,
            detail_level: str = "basic",
            include_metrics: bool = True,
            include_health: bool = True,
            include_performance: bool = False,
            device_filter: str | None = None,
            time_range: str = "1h",
        ) -> dict[str, Any]:
            """Comprehensive system status and health monitoring.

            This tool provides detailed status information:
            - overview: Overall system status
            - devices: Device status and health
            - network: Network connectivity and performance
            - services: Service status (API, monitoring, etc.)
            - metrics: Key performance metrics
            - alerts: Current alerts and issues
            - health: Overall health assessment
            - mcp_server: MCP server capabilities (tools, prompts, resources)

            The mcp_server section includes:
            - tools: Count and list of available tools
            - prompts: Count and list of available prompts (with details at advanced/diagnostic levels)
            - resources: Count and list of available resources and resource templates (with details at advanced/diagnostic levels)

            Args:
                component: Component to check (overview, devices, network, services, metrics, alerts, health)
                detail_level: Detail level (basic, intermediate, advanced, diagnostic)
                include_metrics: Whether to include performance metrics
                include_health: Whether to include health assessments
                include_performance: Whether to include detailed performance data
                device_filter: Filter devices by status or tags
                time_range: Time range for metrics (1h, 6h, 24h, 7d)

            Returns:
                Comprehensive status information with health indicators

            Raises:
                TailscaleMCPError: If status check fails
            """
            try:
                status_info = await self._generate_status_info(
                    component, detail_level, include_metrics, include_health,
                    include_performance, device_filter, time_range
                )
                return {
                    "component": component or "overview",
                    "detail_level": detail_level,
                    "timestamp": time.time(),
                    "status": status_info,
                }

            except Exception as e:
                logger.error("Error generating status information", component=component, error=str(e))
                raise TailscaleMCPError(f"Failed to generate status information: {e}") from e

        logger.info("All portmanteau tools registered successfully")

    async def _generate_help_content(
        self, topic: str | None, level: str, category: str | None,
        operation: str | None, include_examples: bool
    ) -> dict[str, Any]:
        """Generate comprehensive help content."""

        help_data = {
            "overview": {
                "title": "Tailscale MCP Server - Comprehensive Help System",
                "description": "Professional Tailscale MCP server with 10 portmanteau tools and 91+ operations",
                "tools": {
                    "tailscale_device": "Device and user management operations",
                    "tailscale_network": "DNS and network configuration",
                    "tailscale_monitor": "Real-time monitoring and metrics",
                    "tailscale_file": "Secure file sharing via Taildrop",
                    "tailscale_security": "Security scanning and compliance",
                    "tailscale_automation": "Workflow automation and batch operations",
                    "tailscale_backup": "Configuration backup and recovery",
                    "tailscale_performance": "Performance optimization and analysis",
                    "tailscale_reporting": "Advanced reporting and analytics",
                    "tailscale_integration": "Third-party integrations and webhooks",
                    "tailscale_help": "This comprehensive help system",
                    "tailscale_status": "System status and health monitoring",
                },
                "levels": {
                    "basic": "Quick start guide and essential commands",
                    "intermediate": "Detailed tool descriptions and workflows",
                    "advanced": "Technical architecture and implementation details",
                    "expert": "Development troubleshooting and system internals",
                }
            },
            "examples": {
                "basic_device_list": "tailscale_device(operation='list', online_only=True)",
                "advanced_monitoring": "tailscale_monitor(operation='dashboard_create', dashboard_type='network_overview')",
                "security_scan": "tailscale_security(operation='scan', scan_type='comprehensive')",
                "file_transfer": "tailscale_file(operation='send', file_path='/path/to/file', recipient_device='device-id')",
                "help_system": "tailscale_help(topic='overview', level='intermediate')",
                "status_check": "tailscale_status(component='devices', detail_level='advanced')",
            },
            "best_practices": {
                "security": "Always use comprehensive security scans before deploying changes",
                "monitoring": "Set up Grafana dashboards for continuous monitoring",
                "backup": "Schedule regular configuration backups",
                "performance": "Monitor latency and bandwidth regularly",
                "automation": "Use workflows for repetitive tasks",
            },
            "troubleshooting": {
                "connection_issues": "Check network connectivity and API credentials",
                "performance_problems": "Use tailscale_performance tool for analysis",
                "security_alerts": "Review tailscale_security scan results",
                "device_problems": "Check device status with tailscale_status",
            }
        }

        if topic == "overview" or topic is None:
            return help_data["overview"]
        elif topic == "examples":
            return help_data["examples"]
        elif topic == "best_practices":
            return help_data["best_practices"]
        elif topic == "troubleshooting":
            return help_data["troubleshooting"]
        else:
            return {"error": f"Help topic '{topic}' not found", "available_topics": list(help_data.keys())}

    async def _generate_status_info(
        self, component: str | None, detail_level: str, include_metrics: bool,
        include_health: bool, include_performance: bool, device_filter: str | None, time_range: str
    ) -> dict[str, Any]:
        """Generate comprehensive status information."""

        # Get basic device information
        try:
            devices = await self.device_manager.list_devices()
            online_devices = [d for d in devices if d.get("online", False)]

            # Get network metrics
            network_metrics = await self.monitor.get_network_metrics()

            # Get MCP server capabilities (tools, prompts, resources)
            tools = await self.mcp._list_tools_mcp()
            prompts = await self.mcp._list_prompts_mcp()
            resources = await self.mcp._list_resources_mcp()
            resource_templates = await self.mcp._list_resource_templates_mcp()

            status_data = {
                "system": {
                    "status": "operational",
                    "version": "2.0.0",
                    "uptime": "Running",
                    "last_updated": time.time(),
                },
                "mcp_server": {
                    "tools": {
                        "count": len(tools),
                        "names": [tool.name for tool in tools] if detail_level in ["intermediate", "advanced", "diagnostic"] else None,
                    },
                    "prompts": {
                        "count": len(prompts),
                        "names": [prompt.name for prompt in prompts] if detail_level in ["intermediate", "advanced", "diagnostic"] else None,
                        "list": [
                            {
                                "name": prompt.name,
                                "description": getattr(prompt, "description", None),
                            }
                            for prompt in prompts
                        ] if detail_level in ["advanced", "diagnostic"] else None,
                    },
                    "resources": {
                        "count": len(resources),
                        "templates_count": len(resource_templates),
                        "uris": [str(resource.uri) for resource in resources] if detail_level in ["intermediate", "advanced", "diagnostic"] else None,
                        "templates": [
                            {
                                "uriTemplate": str(template.uriTemplate),
                                "name": getattr(template, "name", None),
                                "description": getattr(template, "description", None),
                            }
                            for template in resource_templates
                        ] if detail_level in ["advanced", "diagnostic"] else None,
                        "list": [
                            {
                                "uri": str(resource.uri),
                                "name": getattr(resource, "name", None),
                                "description": getattr(resource, "description", None),
                            }
                            for resource in resources
                        ] if detail_level in ["advanced", "diagnostic"] else None,
                    },
                },
                "devices": {
                    "total": len(devices),
                    "online": len(online_devices),
                    "offline": len(devices) - len(online_devices),
                    "online_percentage": round((len(online_devices) / len(devices)) * 100, 2) if devices else 0,
                },
                "network": {
                    "connectivity": "good",
                    "latency": network_metrics.get("average_latency", "N/A"),
                    "bandwidth": network_metrics.get("total_bandwidth", "N/A"),
                    "health_score": network_metrics.get("health_score", 85),
                },
                "services": {
                    "api": "operational",
                    "monitoring": "operational",
                    "grafana": "operational",
                    "taildrop": "operational",
                },
                "health": {
                    "overall": "healthy",
                    "devices": "healthy" if len(online_devices) > 0 else "warning",
                    "network": "healthy",
                    "services": "healthy",
                    "mcp_server": "healthy" if len(tools) > 0 and len(prompts) > 0 and len(resources) > 0 else "warning",
                }
            }

            if include_metrics:
                status_data["metrics"] = {
                    "cpu_usage": "15%",
                    "memory_usage": "45%",
                    "disk_usage": "30%",
                    "network_throughput": "125 Mbps",
                }

            if include_performance:
                status_data["performance"] = {
                    "response_time": "45ms",
                    "throughput": "1.2k requests/sec",
                    "error_rate": "0.1%",
                    "availability": "99.9%",
                }

            return status_data

        except Exception as e:
            logger.error("Error generating status information", error=str(e))

            # Still try to get MCP server info even if other operations fail
            try:
                tools = await self.mcp._list_tools_mcp()
                prompts = await self.mcp._list_prompts_mcp()
                resources = await self.mcp._list_resources_mcp()
                resource_templates = await self.mcp._list_resource_templates_mcp()

                mcp_server_info = {
                    "tools": {
                        "count": len(tools),
                        "names": [tool.name for tool in tools] if detail_level in ["intermediate", "advanced", "diagnostic"] else None,
                    },
                    "prompts": {
                        "count": len(prompts),
                        "names": [prompt.name for prompt in prompts] if detail_level in ["intermediate", "advanced", "diagnostic"] else None,
                        "list": [
                            {
                                "name": prompt.name,
                                "description": getattr(prompt, "description", None),
                            }
                            for prompt in prompts
                        ] if detail_level in ["advanced", "diagnostic"] else None,
                    },
                    "resources": {
                        "count": len(resources),
                        "templates_count": len(resource_templates),
                        "uris": [str(resource.uri) for resource in resources] if detail_level in ["intermediate", "advanced", "diagnostic"] else None,
                        "templates": [
                            {
                                "uriTemplate": str(template.uriTemplate),
                                "name": getattr(template, "name", None),
                                "description": getattr(template, "description", None),
                            }
                            for template in resource_templates
                        ] if detail_level in ["advanced", "diagnostic"] else None,
                        "list": [
                            {
                                "uri": str(resource.uri),
                                "name": getattr(resource, "name", None),
                                "description": getattr(resource, "description", None),
                            }
                            for resource in resources
                        ] if detail_level in ["advanced", "diagnostic"] else None,
                    },
                }
            except Exception as mcp_error:
                logger.warning("Failed to get MCP server info", error=str(mcp_error))
                mcp_server_info = {
                    "tools": {"count": 0},
                    "prompts": {"count": 0},
                    "resources": {"count": 0, "templates_count": 0},
                }

            return {
                "error": f"Failed to generate status: {e!s}",
                "system": {"status": "error"},
                "mcp_server": mcp_server_info,
                "devices": {"total": 0, "online": 0, "offline": 0},
                "network": {"connectivity": "unknown"},
                "services": {"api": "error"},
                "health": {"overall": "error"},
            }
